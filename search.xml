<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>&lt;Java&gt;-2 包装类</title>
      <link href="/2023/06/23/Java-%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
      <url>/2023/06/23/Java-%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-包装类"><a href="#1-包装类" class="headerlink" title="1 包装类"></a>1 包装类</h1><p>包装类（Wrapper）：针对八种基本数据类型相应的引用类型</p><p>有了类的特点，就可以调用类中的方法</p><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>包装类</th><th>父类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>void</td><td>Void</td><td>Object</td></tr></tbody></table></div><h2 id="1-1-装箱和拆箱"><a href="#1-1-装箱和拆箱" class="headerlink" title="1.1 装箱和拆箱"></a>1.1 装箱和拆箱</h2><ul><li><strong>手动装箱和拆箱（JDK5以前）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);<span class="comment">// 手动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> Integer.valueOf(n1);<span class="comment">// 手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();<span class="comment">// 手动拆箱</span></span><br></pre></td></tr></table></figure><ul><li><strong>自动装箱和拆箱（JDK5以后）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n2 = <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer3</span> <span class="operator">=</span> n2;<span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> integer3;<span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><p>虽然可以自动装箱、拆箱，但使用 == 直接比较两个包装类时，仍然是比较其地址。以下比较通常会失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ia</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">ib</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.print(ia == ib);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但，Java实现仍有可能使其成立。Byte、Boolean以及Short、Integer中[-128,127]间的值已经被包装到固定的对象中。对他们的比较可以成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ia</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">ib</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.print(ia == ib);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由此可见，使用==直接比较两个包装类会带来不确定性。尽量使用equals方法对包装类进行比较。</p><p>装箱与拆箱是 <strong>编译器</strong> 的工作。在生成可执行的字节码文件时，编译器已经插入了必要的方法调用。</p><h2 id="1-2-包装类和-String-的相互转换"><a href="#1-2-包装类和-String-的相互转换" class="headerlink" title="1.2 包装类和 String 的相互转换"></a>1.2 包装类和 <code>String</code> 的相互转换</h2><ul><li><p>包装类转<code>String</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> integer + <span class="string">&quot;&quot;</span>;<span class="comment">//方法1（自动拆箱）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> integer.toString();<span class="comment">//方法2（toString方法）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(integer);<span class="comment">//方法3（自动拆箱）</span></span><br></pre></td></tr></table></figure></li><li><p><code>String</code> 转包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//方法1（自动装箱）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);<span class="comment">//方法2（构造器）</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-3-包装类的常用方法"><a href="#1-3-包装类的常用方法" class="headerlink" title="1.3 包装类的常用方法"></a>1.3 包装类的常用方法</h2><ul><li><p><code>Integer.MIN_VALUE</code>：返回最大值</p></li><li><p><code>Double.MAX_VALUE</code>：返回最小值</p></li><li><p><code>byteValue()</code>、<code>doubleValue()</code>、<code>floatValue()</code>、<code>intValue()</code>、<code>longValue()</code>按各种基本数据类型返回该对象的值</p></li><li><p><code>Character.isDigit(int)</code>：判断是不是数字</p><p><code>Character.isLetter(int)</code>：判断是不是字母</p><p><code>Character.isUpperCase(int)</code>：判断是不是大写字母</p><p><code>Character.isLowerCase(int)</code>：判断是不是小写字母</p><p><code>Characher.isWhitespace(int)</code>：判断是不是空格</p></li><li><p><code>Character.toUpperCase(char)</code>：转成大写字母</p><p><code>Character.toLowerCase(char)</code>：转成小写字母</p></li><li><p><code>Integer.parseInt(string)</code>：将 String 内容转为 int</p><p><code>Double.parseDouble(string)</code></p></li><li><p><code>Integer.toBinaryString(int)</code>：将数字转为 2 进制表示的字符串</p><p><code>Integer.toHexString(int)</code>：将数字转为 16 进制表示的字符串</p><p><code>Integer.toOctalString(int)</code>：将数字转为 8 进制表示的字符串</p><p>特别地，浮点数类型的包装类只有转成 16 进制的方法。而 Short、Byte 及其他包装类无此方法</p></li><li><p><code>Integer.bitCount(i int)</code>：统计指定数字的二进制格式中 1 的数量</p></li></ul><h2 id="1-4-strictfp关键字"><a href="#1-4-strictfp关键字" class="headerlink" title="1.4 strictfp关键字"></a>1.4 strictfp关键字</h2><blockquote><p>由于不同处理器对于浮点数寄存采取不同策略（有些处理器使用 64 位寄存 double，有些则是 80 位），对于浮点数的运算在不同平台上可能出现不同结果。</p></blockquote><p>使用 strictfp 关键字标记的方法或类中，所有指令都会使用严格统一的浮点数运算。</p><p>比如，把 main 方法标记为 strictfp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> ᓚᘏᗢ = <span class="number">1</span> / <span class="number">13.97</span>;</span><br><span class="line">    System.out.println(ᓚᘏᗢ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-String类"><a href="#2-String类" class="headerlink" title="2 String类"></a>2 String类</h1><ol><li><p><code>String</code> 对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量对象是用双引号扩起的字符序列。例如 <code>&quot;你好&quot;</code></p></li><li><p>字符串的字符使用 Unicode 字符编码。一个字符（不论字母汉字）占 2 字节</p></li><li><p>常用构造器：</p><ul><li><p><code>String str1 = new String();</code></p></li><li><p><code>String str2 = new String(String original);</code></p></li><li><p><code>String str3 = new String(char[] a);</code></p></li><li><p><code>String str4 = new String(char[] a, int startIndex, int count);</code></p><p>这句意思是：<code>char[]</code> 从 <code>startIndex</code> 起的 <code>count</code> 个字符</p></li></ul></li><li><p><code>String</code> 实现了接口 <code>Serializable</code> 和 <code>Comparable</code> ，可以 串行化和 比较大小</p><p><strong><em>串行化：即，可以被网络传输，也能保存到文件</em></strong></p></li><li><p><code>String</code> 是 <code>final</code> 类，不能被继承</p></li><li><p><code>String</code> 有属性 <code>private final char[] value;</code> 用于存放字符串内容。</p><p><code>value</code> 是 <code>final</code> 属性。其在栈中的地址不能修改，但堆中的内容可以修改。</p></li></ol><h2 id="2-1-String-构造方法"><a href="#2-1-String-构造方法" class="headerlink" title="2.1 String 构造方法"></a>2.1 <code>String</code> 构造方法</h2><ul><li><p>直接指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;哈哈哈&quot;</span>;</span><br></pre></td></tr></table></figure><p>该方法：先从常量池看是否有 <code>&quot;哈哈哈&quot;</code> 数据空间。有的场合，指向那个空间；否则重新创建然后指向。</p><p>这个方法，<code>str1</code> 指向 常量池中的地址。</p></li><li><p>构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;嘿嘿嘿&quot;</span>);</span><br></pre></td></tr></table></figure><p>该方法：先在堆中创建空间，里面维护一个 <code>value</code> 属性，指向或创建后指向常量池的 <code>&quot;嘿嘿嘿&quot;</code> 空间。</p><p>这个方法，<code>str2</code> 指向堆中的地址</p></li></ul><h2 id="2-2-字符串的特性"><a href="#2-2-字符串的特性" class="headerlink" title="2.2 字符串的特性"></a>2.2 字符串的特性</h2><ul><li><p>常量相加，看的是池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span> + <span class="string">&quot;bb&quot;</span>;<span class="comment">//常量相加，看的是池</span></span><br></pre></td></tr></table></figure><p>上例由于构造器自身优化，相当于 <code>String str1 = &quot;aabb&quot;;</code></p></li><li><p>变量相加，是在堆中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> a + b;<span class="comment">//变量相加，是在堆中</span></span><br></pre></td></tr></table></figure><p>上例的底层是如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(a);</span><br><span class="line">sb.append(b);</span><br><span class="line">str2 = sb.toString();<span class="comment">//sb.toString()：return new String(value, 0, count);</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-String-的常用方法"><a href="#2-3-String-的常用方法" class="headerlink" title="2.3 String 的常用方法"></a>2.3 <code>String</code> 的常用方法</h2><p>以下方法不需死记硬背，手熟自然牢记</p><ul><li><p><code>boolean equals(String s)</code>：区分大小写，判断内容是否相等</p><p><code>boolean equalsIgnoreCase(String s)</code>：判断内容是否相等（忽略大小写）</p></li><li><p><code>boolean empty()</code>：返回是否为空</p></li><li><p><code>int charAt(int index)</code>：获取某索引处的字符（代码单元）。</p><p>必须用 <code>char c = str.charAt(15);</code>，不能用 <code>char c = str[15];</code></p><p><code>int codePointAt(int index)</code></p><p><code>int length()</code>：获取字符（<strong>代码单元</strong>）的个数</p><p><code>IntStream codePoints()</code>：返回字符串中全部码点构成的流</p><p><code>long codePoints().count()</code>：返回真正长度（码点数量）</p></li><li><p><code>int indexOf(String str)</code>：获取字符（串）在字符串中第一次出现的索引。如果找不到，返回 -1</p><p><code>int indexOf(int char)</code> 参数也可以传入一个 int。由于自动类型转换的存在，也能填入 char</p><p><code>int indexOf(String str, int index)</code>：从 index 处（包含）开始查找指定字符（串）</p><p><code>int lastIndexOf(String str)</code>：获取字符在字符串中最后一次出现的索引。如果找不到，返回 -1</p></li><li><p><code>String substring(int start, int end)</code>：返回截取指定范围 [start, end) 的 <strong>新</strong> 字符串</p><p><code>String substring(int index)</code>：截取 index（包含）之后的部分</p></li><li><p><code>String trim()</code>：返回去前后空格的新字符串</p></li><li><p><code>String toUperCase()</code>：返回字母全部转为大写的新字符串</p><p><code>String toLowerCase()</code>：返回字母全部转为小写的新字符串</p></li><li><p><code>String concat(String another)</code>：返回拼接字符串</p></li><li><p><code>String replace(char oldChar, char newChar)</code>：替换字符串中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Foolish cultists&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;cultists&quot;</span>, <span class="string">&quot;believers&quot;</span>);<span class="comment">//str1不变，str2为改变的值</span></span><br></pre></td></tr></table></figure></li><li><p><code>String[] split(String regex)</code>：分割字符串。</p><p>对于某些分割字符，我们需要转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aaa,bbb,ccc&quot;</span>;</span><br><span class="line">String[] strs1 = str1.split(<span class="string">&quot;,&quot;</span>);<span class="comment">//这个场合，strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;4</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;aaa\bbb\ccc&quot;</span>;</span><br><span class="line">String[] strs2 = str2.split(<span class="string">&quot;\\&quot;</span>);<span class="comment">//&quot;\&quot; 是特殊字符，需要转义为 &quot;\\&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>int compareTo(String another)</code>：按照字典顺序比较两个字符串（的大小）。</p><p>返回出现第一处不同的字符的编号差。前面字符相同，长度不同的场合，返回那个长度差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ca&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ccc111abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> str1.compareTo(str2);<span class="comment">//此时 n1 = &#x27;c&#x27; - &#x27;a&#x27; = 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> str1.compareTo(str3);<span class="comment">//此时 n2 = str1,length - str3.length = -6</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> str1.compareTo(str1);<span class="comment">//此时 n3 = 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>char[] toCharArray()</code>：转换成字符数组</p><p><code>byte[] getBytes()</code>：字符串转为字节数组</p></li><li><p><code>String String.format(String format, Object... args)</code>：（静态方法）格式字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Roin&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> <span class="string">&quot;1M&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> <span class="string">&quot;computer&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">formatStr</span> <span class="operator">=</span> <span class="string">&quot;I am %s, I am %s old, I am a %s&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(formatStr, name, age, state);</span><br><span class="line"><span class="comment">//其中 %s 是占位符。此时，str = &quot;I am Roin, I am 1M old, I am a computer&quot;;</span></span><br><span class="line"><span class="comment">//%s 表示字符串替换；%d 表示整数替换；#.2f 表示小数（四舍五入保留2位）替换；%c 表示字符替换</span></span><br></pre></td></tr></table></figure></li><li><p><code>String join(deli, ele...)</code>：拼接字符串（<code>ele...</code>），以 <code>deli</code> 间隔。</p></li><li><p><code>boolean startsWith(str)</code>：测试 str 是否为当前字符串的前缀</p></li><li><p><code>String repeat(int n)</code>：返回该字符串重复 n 次的结果</p></li></ul><h1 id="3-StringBuffer类"><a href="#3-StringBuffer类" class="headerlink" title="3 StringBuffer类"></a>3 <code>StringBuffer</code>类</h1><blockquote><p><code>java.lang.StringBuffer</code> 代表可变的字符序列。可以对字符串内容进行增删。</p><p>很多方法和 <code>String</code> 相同，但 <code>StringBuffer</code> 是可变长度。同时，<code>StringBuffer</code> 是一个容器</p></blockquote><ol><li><p><code>StringBuffer</code> 的直接父类是 <code>AbstractStringBuffer</code></p></li><li><p><code>StringBuffer</code> 实现了 <code>Serialiazable</code>，可以序列化（串行化）</p><p>Java的序列化与串行化得是同一个操作， 序列化是指把一个对象通过某种规则转化为一串二进制串，字符串就是一种二进制串。然后通过协议传输,或者保存成文件，由此可见序列化的目的是为了传输，保存对象。</p></li><li><p>在父类中，<code>AbstractStringBuffer</code> 有属性 <code>char[] value</code> 不是 <code>final</code></p></li><li><p><code>StringBuffer</code> 是一个 <code>final</code> 类，不能被继承</p></li></ol><p><strong><code>String</code> 对比 <code>StringBuffer</code></strong></p><ul><li><code>String</code> 保存字符串常量，其中的值不能更改。每次更新实际上是更改地址，效率较低</li><li><code>StringBuffer</code> 保存字符串变量，里面的值可以更改。每次更新是更新内容，不用每次更新地址。</li></ul><h2 id="3-1-StringBuffer-构造方法"><a href="#3-1-StringBuffer-构造方法" class="headerlink" title="3.1 StringBuffer 构造方法"></a>3.1 <code>StringBuffer</code> 构造方法</h2><ol><li><p>无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br></pre></td></tr></table></figure><p>创造一个 16 位容量的空 <code>StringBuffer</code></p></li><li><p>传入字符串构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcabc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br></pre></td></tr></table></figure><p>（上例）创造一个 str1.length + 16 容量的 <code>StringBuffer</code></p></li><li><p>指定容量构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>（上例）创造一个 3 容量的空 <code>StringBuffer</code></p></li></ol><h2 id="3-2-String-和-StringBuffer的转换"><a href="#3-2-String-和-StringBuffer的转换" class="headerlink" title="3.2 String 和 StringBuffer的转换"></a>3.2 <code>String</code> 和 <code>StringBuffer</code>的转换</h2><ol><li><p>转 <code>StringBuffer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcabc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);<span class="comment">//方法1（构造器）</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">strb1 = strb1.append(str1);<span class="comment">//方法2（先空再append）</span></span><br></pre></td></tr></table></figure></li><li><p>转 <code>String</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> strb1.toString();<span class="comment">//方法1（toString）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(strb1);<span class="comment">//方法2（构造器）</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-3-StringBuffer-的常用方法"><a href="#3-3-StringBuffer-的常用方法" class="headerlink" title="3.3 StringBuffer 的常用方法"></a>3.3 <code>StringBuffer</code> 的常用方法</h2><ul><li><p><code>append(char c)</code>：增加</p><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>delete(start, end)</code>：删减 [start, end) 的内容</p></li><li><p><code>replace(start, end, string)</code>：将 start 与 end 间的内容替换为 string</p></li><li><p><code>indexOf</code>：查找指定字符串第一次出现时的索引。没找到的场合返回 -1</p></li><li><p><code>insert</code>：在指定索引位置之前插入指定字符串</p></li><li><p><code>length()</code>：返回字符长度</p><p><code>capacity()</code>：返回当前的容量</p><p>String 类对象分配内存时，按照对象中所含字符个数等量分配。</p><p>StringBuffer 类对象分配内存时，除去字符所占空间外，会另加 16 字符大小的缓冲区。</p><p>对于 <code>length()</code> 方法，返回的是字符串长度。对于 <code>capacity()</code> 方法，返回的是 字符串 + 缓冲区 的大小。</p></li></ul><h1 id="4-StringBuilder-类"><a href="#4-StringBuilder-类" class="headerlink" title="4 StringBuilder 类"></a>4 <code>StringBuilder</code> 类</h1><blockquote><p>一个可变的字符序列。此类提供一个与 <code>StringBuffer</code> 兼容的 API，但不保证同步（有线程安全问题）。该类被设计成 <code>StringBuffer</code> 的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>。如果可能，建议优先使用该类。因为在大多数实现中，它比起 <code>StringBuffer</code> 要快。</p><p>在 <code>StringBuilder</code> 是的主要操作是 <code>append</code> 和 <code>insert</code> 方法。可以重载这些方法，以接受任意类型的数据。</p></blockquote><ol><li><code>StringBuilder</code> 也继承了 <code>AbstractStringBuffer</code></li><li><code>StringBuilder</code> 也实现了 <code>Serialiazable</code>，可以串行化</li><li>仍然是在父类中有属性 <code>char[] value</code> ，而且不是 <code>final</code></li><li><code>StringBuilder</code> 也是一个 <code>final</code> 类，不能被继承</li><li><code>StringBuilder</code> 的方法，没有做互斥的处理（没有 <code>synchronize</code>），故而存在线程安全问题</li></ol><h2 id="4-1-String、StringBuffer、StringBuilder-的对比"><a href="#4-1-String、StringBuffer、StringBuilder-的对比" class="headerlink" title="4.1 String、StringBuffer、StringBuilder 的对比"></a>4.1 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的对比</h2><ol><li><p><code>StringBuilder</code> 和 <code>StringBuffer</code> 类似，均代表可变字符序列，而且方法也一样</p></li><li><p><code>String</code>：不可变字符序列，效率低，但复用率高</p></li><li><p><code>StringBuffer</code>：可变字符序列，效率较高，线程安全</p></li><li><p><code>StringBuilder</code>：可变字符序列，效率最高，存在线程安全问题</p></li><li><p><code>String</code> 为何效率低：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;<span class="comment">//创建了一个字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">100</span>; n++)&#123;</span><br><span class="line">str1 += <span class="string">&quot;bb&quot;</span>;<span class="comment">//这里，原先的字符串被丢弃，创建新字符串</span></span><br><span class="line">&#125;<span class="comment">//多次执行后，大量副本字符串留在内存中</span></span><br><span class="line"><span class="comment">//导致效率降低，也会影响程序性能</span></span><br></pre></td></tr></table></figure><p>如上，对 <code>String</code> 大量修改的场合，不要使用 <code>String</code></p></li></ol><h1 id="5-Math-类"><a href="#5-Math-类" class="headerlink" title="5 Math 类"></a>5 <code>Math</code> 类</h1><ul><li><p><code>Math.multiplyExact(int n1, int n2)</code>：进行乘法运算，返回运算结果</p><p>通常的乘法 <code>n1 * n2</code> 在结果大于那个数据类型存储上限时，可能返回错误的值。</p><p>使用此方法，结果大于那个数据类型存储上限时，会抛出异常</p><p><code>Math.addExact(int n1, int n2)</code>：加法</p><p><code>Math.subtractExact(int n1, int n2)</code>：减法</p><p><code>Math.incrementExact(int n1)</code>：自增</p><p><code>Math.decrementExact(int n1)</code>：自减</p><p><code>Math.negateExact(int n1, int n2)</code>：改变符号</p></li><li><p><code>Math.abs(n)</code>：求绝对值，返回 |n1|</p></li><li><p><code>Math.pow(n, i)</code>：求幂，返回 n3 ^ i</p></li><li><p><code>Math.ceil(n)</code>：向上取整，返回 &gt;= n3 的最小整数（转成double）</p></li><li><p><code>Math.floor(n)</code>：向下取整，返回 &lt;=n4 的最小整数（转成double）</p></li><li><p><code>Math.floorMod(int n1, int n2)</code>：返回 n1 除以 n2 的余数</p><p><code>n1 % n2</code> 的场合，返回的可能是负数，而不是数学意义上的余数</p></li><li><p><code>Math.round(n)</code>：四舍五入，相当于 <code>Math.floor(n5 + 0.5)</code></p></li><li><p><code>Math.sqrt(n)</code>：求开方。负数的场合，返回 <code>NaN</code></p></li><li><p><code>Math.random()</code>：返回一个 [0, 1) 区间的随机小数</p></li><li><p><code>Math.sin(n)</code>：正弦函数</p><p><code>Math.cos(n)</code>：余弦函数</p><p><code>Math.tan(n)</code>、<code>Math.atan(n)</code>、<code>Math.atan2(n)</code></p><p>要注意，上述方法传入的参数是 <strong>弧度值</strong>。</p><p>要得到一个角度的弧度值，应使用：<code>Math.toRadians(n)</code></p></li><li><p><code>Math.exp(n)</code>：e 的 n 次幂</p><p><code>Math.log10(n)</code>：10 为底的对数</p><p><code>Math.log()</code>：自然对数</p></li><li><p><code>Math.PI</code>：圆周率的近似值</p><p><code>Math.E</code>：e 的近似值</p></li></ul><h1 id="6-Arrays-类"><a href="#6-Arrays-类" class="headerlink" title="6 Arrays 类"></a>6 <code>Arrays</code> 类</h1><ul><li><p><code>Arrays.toString()</code>：返回数组的字符串形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">33</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Array.toString(nums);<span class="comment">//此时，str = &quot;[0, 1, 33]&quot;</span></span><br></pre></td></tr></table></figure><p>特别的，输入为 null 时返回 “null”</p></li><li><p><code>Arrays.sort(arr)</code>：排序</p><p>因为数组是引用类型，使用 sort 排序后，会直接影响到实参。</p><p>默认（自然排序）从小到大排序。</p><p><code>Arrays.sort(arr, Comparator c)</code>：按照传入的比较器决定排序方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums;</span><br><span class="line">...</span><br><span class="line">Comparator&lt;Integer, Integer&gt; c = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer, Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n2 - n1;<span class="comment">// 这个场合，变成从大到小排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(nums, c);</span><br></pre></td></tr></table></figure></li><li><p><code>Arrays.binarySearch(array, num)</code>：通过二分搜索法查找。前提是必须先排序。</p><p>找不到的场合，返回 - (low + 1)。即，其应该在的位置的负值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums2 = &#123;-<span class="number">10</span>, -<span class="number">5</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(nums2, <span class="number">7</span>);<span class="comment">// 此时 index = -7</span></span><br><span class="line"><span class="comment">// 如果 7 存在，应该在第 7 个位置</span></span><br></pre></td></tr></table></figure></li><li><p><code>Arrays.copyOf(arr, n)</code>：从 <code>arr</code> 中，复制 n 个元素（成为新的数组）。</p><p>n &gt; arr.length 的场合，在多余的位置添加 <code>null</code>。n &lt; 0 的场合，抛出异常。</p><p>该方法的底层使用的是 <code>System.arraycopy</code></p></li><li><p><code>Arrays.fill(arr, o)</code>：用 o 填充 <code>num</code> 的所有元素。</p></li><li><p><code>Arrays.equals(arr1, arr2)</code>：比较两个数组元素是否完全一致（<code>true</code>/<code>false</code>）</p></li><li><p><code>Arrays.asList(a, b, c, d)</code>：将输入数据转成一个 <code>List</code> 集合</p></li></ul><h1 id="7-System-类"><a href="#7-System-类" class="headerlink" title="7 System 类"></a>7 <code>System</code> 类</h1><ul><li><p><code>System.exit(0)</code>：退出当前程序。0 表示一个状态，正常状态是 0</p></li><li><p><code>System.arraycopy(arr, 0, newArr, 0 ,3)</code>：复制数组元素。</p><p>上例是：arr 自下标 0 起开始，向 newArr 自下标 0 开始，依次拷贝 3 个值</p><p>这个方法比较适合底层调用。我们一般使用 <code>Arrays.copyOf</code> 来做</p></li><li><p><code>System.currentTimeMillis</code>：返回当前时间距离 1970 - 1 - 1 的毫秒数</p></li><li><p><code>System.gc</code>：运行垃圾回收机制</p></li></ul><h1 id="8-BigInteger-和-BigDecimal-类"><a href="#8-BigInteger-和-BigDecimal-类" class="headerlink" title="8 BigInteger 和 BigDecimal 类"></a>8 <code>BigInteger</code> 和 <code>BigDecimal</code> 类</h1><p><code>BigInteger</code>：适合保存更大的整数</p><p><code>BigDecimal</code>：适合保存精度更大的浮点数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用引号把大数变成字符串</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100000000000000000000000&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>构造方法：</strong></p><ul><li><code>new BigInteger(String intStr)</code>：通过一个字符串构建大数</li><li><code>BigInteger BigInteger.valueOf(1)</code>：通过静态方法，让整数类型转成大数</li></ul><p>另外，在对 <code>BigInteger</code> 和 <code>BigDecimal</code> 进行加减乘除的时候，需要使用对应方法,不能直接用 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p><p><strong>常用方法：</strong></p><ul><li><p><code>BigInteger add(BigInteger)</code>：加法运算。返回新的大数</p></li><li><p><code>BigInteger subtract(BigInteger)</code>：减法</p></li><li><p><code>BigInteger multiply(BigInteger)</code>：乘法</p></li><li><p><code>BigInteger divide(BigInteger)</code>：除法运算</p><p>该方法可能抛出异常。因为可能产生是无限长度小数。</p><p>解决方法（保留分子精度）：<code>bigDecimal.divide(bD3, BigDecimal.ROUND_CELLING)</code></p></li><li><p>一些常量：</p><p><code>BigInteger.ONE</code>、<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code> 分别是 1、0、10</p><p>one 就是英文的 1，zero 就是英文的 0……这个大家都懂的吧？</p></li></ul><h1 id="9-日期类"><a href="#9-日期类" class="headerlink" title="9 日期类"></a>9 日期类</h1><h2 id="9-1-第一代日期类"><a href="#9-1-第一代日期类" class="headerlink" title="9.1 第一代日期类"></a>9.1 第一代日期类</h2><blockquote><p>Date：精确到毫秒，代表特定瞬间。这里的是 java.util.Date</p><p>SimpleDateFormat：格式和解析日期的类</p></blockquote><ol><li><p><code>Date d1 = new Date();</code>：调用默认无参构造器，获取当前系统时间。</p><p>默认输出日期格式是国外的格式，因此通常需要进行格式转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd HH.mm.ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateFormated</span> <span class="operator">=</span> sdf.(d1);<span class="comment">//日期转成指定格式。</span></span><br></pre></td></tr></table></figure></li><li><p>通过指定毫秒数得到时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">10000000000</span>);</span><br></pre></td></tr></table></figure></li><li><p>把一个格式化的字符串转成对应的 Date：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH点mm分 E&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> sdf2.parse(<span class="string">&quot;2021年12月22日 00点03分 星期三&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个场合，给定的字符串格式应和 <code>sdf2</code> 格式相同，否则会抛出异常</p></li></ol><h2 id="9-2-第二代日期类"><a href="#9-2-第二代日期类" class="headerlink" title="9.2 第二代日期类"></a>9.2 第二代日期类</h2><blockquote><p>Calendar：构造器是私有的，要通过 getInstance 方法获取实例</p></blockquote><ol><li><p>Calendar 是一个抽象类，其构造器私有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.genInstance();<span class="comment">//获取实例的方法</span></span><br></pre></td></tr></table></figure></li><li><p>提供大量方法和字段提供给程序员使用</p><p><code>c1.get(Calendar.YEAR)</code>：获取年份数</p><p><code>c1.get(Calendar.MONTH)</code>：获取月份数,特别的，实际月份是 返回值 +1。因为 Calendar 的月份是从 0 开始编号的</p><p><code>c1.get(Calendar.DAY_OF_MONTH)</code>：获取日数</p><p><code>c1.get(Calendar.HOUR)</code>：获取小时数（12小时制）</p><p><code>c1.get(Calendar.HOUR_OF_DATE)</code>：获取小时数（24小时制）</p><p><code>c1.get(Calendar.MINUTE)</code>：获取分钟数</p><p><code>c1.get(Calendar.SECOND)</code>：获取秒数</p></li></ol><p>Calendar 没有专门的格式化方法，需要程序员自己组合来显示</p><h2 id="9-3-第三代日期类"><a href="#9-3-第三代日期类" class="headerlink" title="9.3 第三代日期类"></a>9.3 第三代日期类</h2><blockquote><p>JDK 1.0 加入的 Date 在 JDK 1.1 加入 Calendar 后已被弃用</p><p>然而，Calendar 也存在不足：</p><ol><li>可变性：像日期和实际这样的类应该是不可改变的</li><li>偏移性：年份都是从 1900 年开始，月份都是从 0 开始</li><li>格式化：只对 Date 有用，对 Calendar 没用</li><li>其他问题：如不能保证线程安全，不能处理闰秒（每隔 2 天多 1 秒）等</li></ol><p>于是，在 JDK 8 加入了以下新日期类：</p><ul><li>LocalDate：只包含 日期（年月日），可以获取 日期字段</li><li>LocalTime：只包含 时间（时分秒），可以获取 时间字段</li><li>LocalDateTime：包含 日期 + 时间，可以获取 日期 + 时间字段</li><li>DateTimeFormatter：格式化日期</li><li>Instant：时间戳</li></ul></blockquote><ol><li><p>使用 <code>now()</code> 方法返回当前时间的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();<span class="comment">//获取当前时间</span></span><br></pre></td></tr></table></figure></li><li><p>获取各字段方法：</p><p><code>ldt.getYear();</code>：获取年份数</p><p><code>ldt.getMonth();</code>：获取月份数（英文）</p><p><code>ldt.getMonthValue();</code>：获取月份数（数字）</p><p><code>ldt.getDayOfMonth();</code>：获取日数</p><p><code>LocalDateTime ldt2 = ldt.plusDays(100);</code>：获取 ldt 时间 100 天后的时间实例</p><p><code>LocalDateTime ldt3 = ldt.minusHours(100);</code>：获取 ldt 时间 100 小时前的时间实例</p></li><li><p>格式化日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTimeFormatter</span>(<span class="string">&quot;yyyy.MM.dd HH.mm.ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> dtf.format(ldt);<span class="comment">//获取格式化字符串</span></span><br></pre></td></tr></table></figure></li><li><p><code>Instant</code> 和 <code>Date</code> 类似</p><p>获取当前时间戳：<code>Instant instant = Instant.now();</code></p><p>转换为 <code>Date</code>：<code>Date date = Date.form(instant);</code></p><p>由 <code>Date</code> 转换：<code>Instant instant = date.toInstant;</code></p></li></ol><h1 id="10-泛型"><a href="#10-泛型" class="headerlink" title="10 泛型"></a>10 泛型</h1><blockquote><p>泛型（generic）：又称 参数化类型。是JDK 5 出现的新特性。解决数据类型的安全性问题。</p><p>在类声明或实例化时只要制定好需要的具体类型即可。</p></blockquote><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Properties&lt;Person&gt; prop = <span class="keyword">new</span> <span class="title class_">Properties</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>上例表示存放到 <code>prop</code> 中的必须是 <code>Person</code> 类型。</p><p>如果编译器发现添加类型不符合要求，即报错。</p><p>遍历时，直接取出 <code>Person</code> 而非 <code>Object</code></p></blockquote><ol><li><p>编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生 ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。</p></li><li><p>也减少了转换的次数，提高了效率。</p></li><li><p>泛型的作用是：可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&lt;E&gt; &#123;</span><br><span class="line">E e;<span class="comment">//E 表示 e 的数据类型，在定义 P类 时指定。在编译期间即确认类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">P</span><span class="params">(E e)</span>&#123;<span class="comment">//可作为参数类型</span></span><br><span class="line"><span class="built_in">this</span>.e = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">doSth</span><span class="params">()</span>&#123;<span class="comment">//可作为返回类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化时指定 E 的类型，编译时上例所有 E 会被编译器替换为那个指定类型</p></li></ol><p><strong>使用方法：</strong></p><ul><li><p><strong>声明泛型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&lt;T&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;A, B, C, D&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>上例 T、A、B、C、D 不是值，而是类型。可以用任意字母代替</p></li><li><p><strong>实例化泛型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; iterator = vector.interator&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>类名后面指定类型参数的值</p></li></ul><p><strong>注意细节：</strong></p><ol><li><p>泛型只能是引用类型</p></li><li><p>指定泛型具体类型后，可以传入该类型或其子类类型</p></li><li><p>在实际开发中往往简写泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>编译器会进行类型推断，右边 <code>&lt; &gt;</code> 内容可以省略</p></li><li><p>实例化不写泛型的场合，相当于默认泛型为 <code>Object</code></p></li></ol><p><strong>自定义泛型类 · 接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>&lt;A, B...&gt; &#123;...&#125;<span class="comment">//泛型标识符 可有多个，一般是单个大写字母表示</span></span><br></pre></td></tr></table></figure><p>这就是自定义泛型</p><ol><li><p>普通成员可以使用泛型（属性、方法）</p></li><li><p>泛型类的类型，是在创建对象时确定的。</p><p>因此：静态方法中不能使用类的泛型；使用泛型的数组，也不能初始化。</p></li><li><p>创建对象时不指定的场合，默认 Object。建议还是写上 <code>&lt;Object&gt;</code>，大气，上档次</p></li><li><p>自定义泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span>&lt;T, R...&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><p>泛型接口，其泛型在 继承接口 或 实现接口 时确定。</p></li></ol><p><strong>自定义泛型方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T, R...&gt; 返回类型 方法名(形参) &#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li><p>可以定义在普通类中，也可以定义在泛型类中</p></li><li><p>当泛型方法被调用时，类型会确定</p></li><li><p>以下场合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class C&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cMethord</span><span class="params">(T t)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有 <code>&lt; &gt;</code>，不是泛型方法，而是使用了泛型的普通方法</p></li></ol><p><strong>泛型继承：</strong></p><ol><li>泛型不具有继承性</li><li><code>&lt;?&gt;</code>：支持任意泛型类型</li><li><code>&lt;? extends A&gt;</code>：支持 A 及 A的子类，规定了泛型的上限</li><li><code>&lt;? super B&gt;</code>：支持 B 及 B 的父类，规定了泛型的下限</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计师-数据库系统</title>
      <link href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/04/30/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-三级模式-两级映射"><a href="#1-三级模式-两级映射" class="headerlink" title="1 三级模式-两级映射"></a>1 三级模式-两级映射</h1><blockquote><p>层次性的架构设计，为我们应用的时候提供了很多方面的便利。让整个体系的可维护性、应变能力变得更好一些了</p></blockquote><p>从示意图上可以看到，物理数据库在系统合计算机上的表现形式往往就是一个文件，Access数据库、SQL Server数据库在最后还是一个文件。在SQL Server数据库中除了数据库文件以外，还有日志文件这些。</p><p>数据库系统结构分成三个级别的层次，即：内模式、概念模式、外模式。</p><ol><li>内模式（又称物理数据库模式）：它是和物理层次数据库直接关联的，负责管理存储数据的方式，即数据应该以什么格式存放在物理文件上面，以及如何优化这些存储方式；该模式的关注点在于数据如何存放在上面（这是内模式应该考虑的职责）</li><li>概念模式（又称概念级数据库）：即数据库中的“表”，在该模式中，根据业务以及应用，数据被分成了若干张“表”，表之间会有相应的关联。</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;软件设计师&gt;-2 操作系统基本原理</title>
      <link href="/2023/04/05/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/05/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>重点：银行家算法、pv操作、文件管理、存储管理、操作系统的分类及其特点</p></blockquote><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/image-20230405203504307.png" alt="计算机结构"></p><p><strong>操作系统的作用</strong>：</p><ul><li>管理系统的硬件、软件、数据资源</li><li>控制程序运行</li><li>人机之间的接口</li><li>应用软件与硬件之间的接口</li></ul><p>如果说我们把计算机买回来后，没有装操作系统，你是没有办法控制计算机上的资源的。相反我们安装上操作系统就能管理系统的硬件、软件、数据资源，说明操作系统是人与硬件之间的一种接口。对人机之间来说接口往往是以命令的方式存在，在这个过程中不是很直观，后来就出现了windows系统，也就是图形化界面。故命令和窗口的方式就是人机之间的接口。应用软件与硬件之间的接口是指操作系统专门为应用软件提供的API接口来实现相关的功能。</p><p><strong>操作系统的五种作用：</strong></p><ol><li>进程管理：进程的状态、前驱图、PV操作、死锁问题</li><li>存储管理：段页式存储、页面置换算法</li><li>文件管理：索引文件、位示图</li><li>作业管理</li><li>设备管理</li></ol><p>微内核操作系统包含虚设备与SPOOLING技术</p><h1 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2 进程管理"></a>2 进程管理</h1><h2 id="2-1-进程的状态"><a href="#2-1-进程的状态" class="headerlink" title="2.1 进程的状态"></a>2.1 进程的状态</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/image-20230405224927476.png" alt="进程状态的演变"></p><h2 id="2-2-前驱图"><a href="#2-2-前驱图" class="headerlink" title="2.2 前驱图"></a>2.2 前驱图</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/image-20230405225338792.png" alt="前驱图"></p><p>概念：前驱图是将一个完整的进程所需的工序按照是否具有先后关系和约束关系将进程再次区分的图像</p><font color="red">前驱图能直观的让我们知道哪些任务可以并行，哪些任务有先后关系</font><h2 id="2-3-进程的同步与互斥"><a href="#2-3-进程的同步与互斥" class="headerlink" title="2.3 进程的同步与互斥"></a>2.3 进程的同步与互斥</h2><blockquote><p>互斥就是再同一时刻只允许某一个进程使用这一个资源，即同一资源不能服务多个进程</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E5%A4%B4%E5%83%8F/image-20230406124020337.png" alt="互斥"></p><blockquote><p>同步就是运行速度有差异的多个进程同时开始运行，在一定情况下，速度较快的进程会停下来等待速度较慢的进程。同步满足两个条件：速度之间存在差异，存在等待过程。</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E5%A4%B4%E5%83%8F/image-20230406124045046.png" alt="同步"></p><p><strong>经典问题：生产者与消费者问题</strong></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E5%A4%B4%E5%83%8F/image-20230406124148125.png" alt=""></p><p>图注：对于单缓存情况而言，市场是一个互斥资源只允许一个人进行操作，不允许多个人进行操作，操作包括生产者放置商品和消费者拿走商品。生产者放置一个商品在市场中，然后如果我们还想要再放置商品就会出现溢出情况，那么只有等待商品被消费者拿走，才能放置下一个商品；存在速度差异和等待过程，这就是同步的情况。多缓存情况一样，只不过放置商品变多了。</p><h2 id="2-4-PV操作"><a href="#2-4-PV操作" class="headerlink" title="2.4 PV操作"></a>2.4 PV操作</h2><ul><li>临界资源：诸进程间需要互斥方式对其进行共享的资源，如打印机、磁带机等</li><li>临界区：每个进程中访问临界资源的那段代码称为临界区</li><li>信号量：是一种特殊的变量</li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E5%A4%B4%E5%83%8F/image-20230406124553142.png" alt=""></p><ul><li>P操作的主要动作是<ul><li>S减一</li><li>若S减一后仍大于或等于0，则进程继续执行</li><li>若S减一后小于0，则该进程被阻塞后放入等待该信号量的进程队列中，然后转进程调度</li></ul></li><li>V操作的主要动作是：<ul><li>S加一</li><li>若相加后结果大于0，则进程继续执行</li><li>若相加后结果小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度</li></ul></li></ul><p><strong>单缓冲区生产者、消费者问题PV原语描述：</strong></p><p>系统里面有两个进程——消费者和生产者</p><p>假设当前进程为生产者进程，我们首先进行生产一个产品P（s1），<code>s1 = s1 - 1 = 0</code>，进程继续向下执行，即将产品放置到缓存区V(s2)，<code>s2 = s2 + 1 = 1</code>，然后我们再执行一遍生产者进程，执行P（s1），<code>s1 = s1 - 1 = -1 &lt; 0</code>，则该进程放置到进程队列中，也就是该进程阻塞起来了。我们再来执行消费者进程，执行P（s2），<code>s2 = s2 - 1 = 0</code>，继续向下执行V（s1），<code>s1 = s1 + 1 = 0 &lt;= 0</code>，从s1信号的等待队列中释放一个等待进程，也就是生产者进程，生产者就继续向下执行。假设一开始先执行消费者进程，执行P（s2），<code>s2 = s2 - 1 = -1</code>，不能够继续执行，因为s2小于0会被阻塞，故而消费者一开始就执行产生的错误可以使用PV操作进行避免。</p><p><strong><font color="red">PV操作所解决的问题其实就是并发进程之间某些约束关系之间的解决方案</font></strong></p><h3 id="2-4-1-例题"><a href="#2-4-1-例题" class="headerlink" title="2.4.1 例题"></a>2.4.1 例题</h3><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151607075.png" alt=""></p><p>假设没有b1，b2操作，收银员执行收费动作，但是没有付款哪来的收费，故b1就是一个P操作阻塞收银员进程。这个P操作由付款动作V操作进行唤醒，那么a1是一个V操作。同一对PV操作的信号量需要一样。另外，V操作不具有阻塞功能，故a2是P操作用于阻塞购书者进程然后转进程调度，因为顾客不是付款后就能走，还应该结账等到收银员同意之后才能走。</p><p>总结：</p><p>PV操作解题的核心关键点就是找出约束关系，在进程中模拟假设执行哪个进程会遇到什么问题，应该在哪里有什么约束，假设执行另一个进程又会面临什么问题，把PV操作加进来能够解决就是正确答案了</p><p><strong><font color="red">P阻塞，V执行</font></strong></p><h3 id="2-4-2-PV操作与前驱图"><a href="#2-4-2-PV操作与前驱图" class="headerlink" title="2.4.2 PV操作与前驱图"></a>2.4.2 PV操作与前驱图</h3><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151625952.png" alt=""></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151628703.png" alt="例题"></p><h2 id="2-5-死锁问题"><a href="#2-5-死锁问题" class="headerlink" title="2.5 死锁问题"></a>2.5 死锁问题</h2><blockquote><p>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁</p></blockquote><p><strong>解决方案：</strong>提高系统资源容量；常见题型：计算机系统至少需要多少资源将不可能发送死锁问题</p><p>例如系统有3个进程：A、B、C，这3个进程都需要5个系统资源。如果系统至少有多少个资源不会发生死锁</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151643851.png" alt=""></p><p>一个进程在得到所有所需资源并执行结束之后将释放自身占用的资源，如果3个进程恰好都分配4个资源就会出现死锁问题，那么我们再加上一个资源就能打破死锁情况，故该系统至少需要13个资源。</p><p>计算方法：<strong>k∗(n−1)+1(n表示系统资源，k表示进程个数)</strong></p><h2 id="2-6-银行家算法"><a href="#2-6-银行家算法" class="headerlink" title="2.6 银行家算法"></a>2.6 银行家算法</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151656975.png" alt=""></p><h3 id="2-6-1-死锁的四大必要条件"><a href="#2-6-1-死锁的四大必要条件" class="headerlink" title="2.6.1 死锁的四大必要条件"></a>2.6.1 死锁的四大必要条件</h3><ol><li>互斥：如果进程使用的不是互斥资源，那么就不存在死锁的想法了，资源就是共享的</li><li>保持和等待：在资源总量并未满足完成进程所需资源的总量前提下，每个进程都保持自身占用的资源不变并且一直等待其他进程完成以获取其释放的系统资源</li><li>不剥夺：系统不会把已分配给一个进程的资源剥夺掉分配给其他进程</li><li>环路等待：如总共有三个进程，A等待B给它释放资源，B等待C给它释放资源，C等待A给它释放资源，这样子就形成了环路等待</li></ol><blockquote><p>解决死锁问题有两种方案——预防和避免</p></blockquote><h3 id="2-6-2-死锁的预防与避免"><a href="#2-6-2-死锁的预防与避免" class="headerlink" title="2.6.2 死锁的预防与避免"></a>2.6.2 死锁的预防与避免</h3><ol><li>死锁的预防就是通过打破四大必要条件来进行。</li><li>死锁的避免分成两种有序资源分配法和银行家算法。</li></ol><p><strong>有序资源分配法</strong></p><p>就是将资源先分给A进程，再分给B进程，再分给C进程以此类推。将系统资源按照顺序分配给进程，一个进程完成后才能将资源分配给下一个进程。该方法的资源的利用率比较低，所以一般我们会采取更加有效比较多的方案是银行家算法。</p><p><strong>银行家算法</strong></p><p>是以银行放贷的思路来做资源的分配。因为对于银行家而言他们眼中的资源就是钱，他们放贷时，考虑这个钱是否能够按时收回。如果这个钱一评估发现收不回来，银行家就不会放这笔贷款出去。所以对于操作系统而言，如果系统把资源分配给一个进程，而这个进程没有办法偿还，会造成系统的一些风险，那么系统就不会分配给你资源。</p><p>银行家算法分配资源的原则：</p><ul><li>当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程</li><li>进程可以分期请求资源，但请求的总数不能超过最大需求量</li><li>当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源</li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151706237.png" alt="例题"></p><p><strong>解</strong>：系统状态是安全的，就是不出现死锁状态。<br>一个进程在得到所有所需资源并执行结束之后将释放自身占用的资源。</p><p>解题思路：首先求剩下的资源数，然后计算<code>已经分配资源数 + 现有资源数</code>是否能够满足最大需求数，就能判断执行流程是否安全。</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151713547.png" alt=""></p><h1 id="3-存储管理"><a href="#3-存储管理" class="headerlink" title="3 存储管理"></a>3 存储管理</h1><h2 id="3-1-分区存储组织"><a href="#3-1-分区存储组织" class="headerlink" title="3.1 分区存储组织"></a>3.1 分区存储组织</h2><p>应用场景：有一个存储区域，除了给系统使用的内存空间，还有一个连续的大的空白（或者用户）区域，用户区域是供应用程序调用内存的时候使用的</p><p>某计算机系统的内存大小为128 k 128k128k, 采用可变分区分配方式进行内存分配, 当前系统的内存分块情况如下图所示, 现有作业4申请内存9 k 9k9k，几种不同的存储分配算法在分配中, 会产生什么样的结果呢?</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151730634.png" alt=""></p><h2 id="3-2-页式存储组织"><a href="#3-2-页式存储组织" class="headerlink" title="3.2 页式存储组织"></a>3.2 页式存储组织</h2><p><strong>提出背景：</strong></p><p>之前提出分区化存储管理，即在内存当中划分一个用户区域，用户区域是供用户调用内存使用的，在这种管理模式当中往往是把应用程序整体都调用到内存当中。比如：内存空间有4G，用户空间有2G，现在你运行2G以上的程序都不行，甚至是1G都够呛。因为用户空间经过分区存储组织后是碎片化的，不是连续的空间，不能一次性的装入。为了解决碎片化的存储提出了页式存储</p><p><strong>具体思路：</strong></p><p>把用户程序分成等份大小的页（比如：等分n个4k大小的区域，每个区域称为页），把内存当中的存储区也分成等份大小（块大小与页的大小相同）的块，然后调用程序时，不再是将程序一次性地调入，而是需要哪些页就通过页表调用到相应的块中。（页表用于记录页和块的映射关系）如果我们采用这种方式就能将之前超越内存容量的应用程序运行问题解决掉了。比如：你的运行内存是2G，也能运行4G的应用程序，因为用到哪些页就是调用，不用就调走，这样就能有效的处理大型任务了。</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151811655.png" alt=""></p><blockquote><p>优点：利用率高，碎片小，分配及管理简单</p><p>缺点：增加了系统开销（比如：读取页表和查找页表的映射关系都会增加系统开销）；可能产生抖动现象</p></blockquote><h3 id="3-2-1-逻辑地址和物理地址"><a href="#3-2-1-逻辑地址和物理地址" class="headerlink" title="3.2.1 逻辑地址和物理地址"></a>3.2.1 逻辑地址和物理地址</h3><ol><li><p>高级程序语言使用逻辑地址</p><p>运行状态，内存中使用物理地址</p></li><li><p>逻辑地址=页号+页内地址</p><p>物理地址=块号+页内地址</p></li><li><p>逻辑地址和物理地址的<strong>页内地址是相同</strong>的，因为我们调入的应用程序都是以页为单位，所以以页为单位的偏移量不会有变化</p><p>逻辑地址和物理地址的<strong>块号是不相同</strong>的，当然你也可以做到相同。比如：将页号0对应块号0.因为这里没有严格的限制，所以页号和块号要通过查表才能够得知</p></li></ol><font color="red">那么我们如何通过逻辑地址求物理地址呢？</font><p>首先知道逻辑地址中哪一部分是页号，哪一部分是页内地址，然后将页内地址写入到物理地址中，然后再通过页号去查找块号，将两者拼接起来即可</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151822193.png" alt=""></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151822034.png" alt="例题"></p><blockquote><p>注：</p><ol><li>页面大小现在普遍是4k</li><li>带有访问位和修改为的页表：访问位0表示最近没有被访问，1表示最近已被访问；修改位0表示该页未被修改，1表示已被修改</li></ol></blockquote><p>转换为物理地址需要知道页内地址，而页内地址需要通过页面大小确定，页面大小转换为二进制为<code>4K=4*2^10=2^12</code>，那么也就是逻辑地址的二进制的后12位就是页内地址即A29（H表示十六进制），而前面的就是页号即为5，通过页表找到对应的块号（页帧号）即6，那么物理地址为6A29H。</p><p>根据表中状态位等于1和0分别表示页面在内存和不在内存，页面的淘汰必然是淘汰在内存的页面，故而应该从0，1，2，5页面中进行淘汰，至于淘汰哪一个就要看访问位了。访问位1说明访问过，还有可能接着访问，所以不能淘汰。比如循环里的语句，要循环100次，访问完还会访问，不要随便淘汰。这里可以用局部性原理解释，被访问过的下次可能还会访问，所以会调入快表，被访问过的不会立即淘汰。故需要淘汰1</p><h2 id="3-3-段式存储组织"><a href="#3-3-段式存储组织" class="headerlink" title="3.3 段式存储组织"></a>3.3 段式存储组织</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151909623.png" alt=""></p><blockquote><p>端式存储中的段包含段号和段内地址两个部分</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151911509.png" alt=""></p><p><strong>具体思路</strong></p><p>按逻辑结构进行划分，即将main主函数作为一个段，然后第一个f(x)子函数作为一个段，再来第二个子函数作为一个段，以此类推。段之间的大小不要求一致（页的大小需要相同），按这种逻辑方式划分最大的好处就是便于共享。</p><p><strong>段表</strong></p><p>其中存储段号、段长（因为段的长度不同）、基址（基地址）就是段在内存空间中是从哪一个地址开始的一个连续空间段，比如：下方段表基址[40K,80K]之间的连续空间</p><p>段的长度是有限的，如果段号长度大于段表长度则判断越界，发出中断信号</p><p><strong>优点：</strong>多道程序共享内存，各段程序修改互不影响</p><p><strong>缺点：</strong>内存利用率低，内存碎片浪费大。因为它要根据段大小在内存空间中切割相应的区块来完成任务</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304151925529.png" alt=""></p><h2 id="3-4-段页式存储组织"><a href="#3-4-段页式存储组织" class="headerlink" title="3.4 段页式存储组织"></a>3.4 段页式存储组织</h2><ol><li>段页式存储是结合了段式和页式的一种存储组织。先分段，再分页</li><li>段页式存储属于折中产物，将两者的优点结合起来</li><li><strong>优点：</strong>空间浪费小、存储共享容易、存储保护容易、能动态连接</li><li><strong>缺点：</strong>由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降（因为需要先查段表再查页表）</li></ol><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161536452.png" alt=""></p><h2 id="3-5-快表"><a href="#3-5-快表" class="headerlink" title="3.5 快表"></a>3.5 快表</h2><blockquote><p>快表是一块小容量的相联存储器（Associative Memory），由高速缓存器组成，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号</p></blockquote><ul><li>相联存储器是按内容进行存储的，速度非常快，效率非常高</li><li>快表是放在cache（高速缓冲器）当中，而段表和页表放在内存当中的就称之为慢表</li></ul><h2 id="3-6-页面置换（淘汰-调度）算法"><a href="#3-6-页面置换（淘汰-调度）算法" class="headerlink" title="3.6 页面置换（淘汰/调度）算法"></a>3.6 页面置换（淘汰/调度）算法</h2><blockquote><p>cache的数量有限，当cache的块都被占了，要调用新的块进来时，就涉及到页面的置换问题。再有就是内存这个体系中同样面临这样一个问题。比方：进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区</p></blockquote><p>选择调出页面的算法就称为页面置换算法。好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。常见的置换算法有以下四种：</p><ul><li><font color="red">最佳（Optimal，OPT）置换算法</font><p>所选择的被淘汰页面将是以后永不使用的，或者是再最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程再内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。但能够利用该算法去评价其它算法</p></li><li><font color="red">随机（RAND）置换算法</font><p>随机淘汰一个页面，具有不稳定性</p></li><li><font color="red">先进先出（FIFO）算法</font><p>优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需要把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p><ul><li>缺点：有可能产生“Belady异常”。例如，4321434543215序列，用3个页面，比4个缺页要少</li><li>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由Belady于1969年发现，故称为Belady异常，只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161621882.png" alt="Belady异常"></p></li><li><font color="red">最近最少使用（LRU）算法</font><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。根据局部性原理解释</p></li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161625320.png" alt=""></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161626011.png" alt="例题"></p><p>”没有使用快表“即表示每读一次程序的块，需要<strong>先在内存上面查表，才能读取到相应的内存块</strong>，所以每一个块需要两次内存的访问，所以6个块(在页式存储结构中，每一个页面对应一个块)总共会产生12次对内存的访问；</p><p>内存的次数是为了读取信息然后进行操作，所以缺页中断和内存访问次数无关；</p><p>一个内存单元占据1B的内存，所有的指令（无论占据了几个页面）都只产生一次缺页，而操作数A和操作数B则各自产生两次缺页中断，因此总共产生了5次缺页中断(规定记住就行)。</p><h2 id="3-7-页面抖动（颠簸）"><a href="#3-7-页面抖动（颠簸）" class="headerlink" title="3.7 页面抖动（颠簸）"></a>3.7 页面抖动（颠簸）</h2><p>在页面置换过程中的一种最糟糕的情况是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>频繁的发送缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提高系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率</p><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4 文件管理"></a>4 文件管理</h1><h2 id="4-1-索引文件结构"><a href="#4-1-索引文件结构" class="headerlink" title="4.1 索引文件结构"></a>4.1 索引文件结构</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161846549.png" alt="索引文件结构"></p><ul><li><p>该结构是一种非常巧妙的文件结构，因为该结构本身容量非常有限，但是引入了一种扩展机制能够很方便地将容量扩大很多倍。</p></li><li><p>一般的索引文件结构是有13个节点，编号从0开始。当然考试中也会存在不是13个节点的文件结构，题目会说明多余节点是什么情况。没有说明就是标准的13结点结构。</p></li><li><p>在索引文件结构中分成了直接索引、一级间接索引、二级间接索引、三级间接索引。分成不同索引等级主要是考虑到文件本身容量的扩展问题。</p></li><li><p>假设一个物理盘块是4K大小，假设所有的结点都是直接索引，那么这个文件最大就是<code>4K × 13 = 52K</code>，容量只有这些实在太小了，故有人引入了一种扩展机制。</p></li><li><p>索引节点存储1~ 13的地址。</p><p>我们规定0~ 9的地址是直接索引，地址对应的物理盘块，物理盘块存储内容。容量为<code>4K × 10=40K</code>。</p><p>第10个索引节点对应的盘块存储的是物理盘块的地址，每一个地址假设占4字节(byte，B)，每个物理盘块为<code>4 * 2^&#123;10&#125;B / 4B = 1024B</code>说明10号结点存储了1024个地址，每个地址对应一个物理盘块，那么容量为<code>4K×1024=4064K</code></p><p>第11个索引节点对应的盘块存储的是地址，地址下一级对应的盘块存储的还是地址，最后才指向物理盘块，那么容量为<code>4 K × 1024 × 1024</code></p><p>依次类推，第12个索引节点对应的盘块是三级索引文件结构,容量为<code>4 K × 1024 × 1024 × 1024</code></p></li><li><p>虽然分级越多存储的内容越多，但相应的，效率也会更低</p></li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161858402.png" alt=""></p><p>逻辑块号往往是从0开始的。分析iaddr[5]为一级间接索引，那么能够存储<code>1KB ÷ 4=256</code>个地址，那么187对应的物理块号就是第<code>256 + 4 + 1</code>号</p><h2 id="4-2-文件和树型目录结构"><a href="#4-2-文件和树型目录结构" class="headerlink" title="4.2 文件和树型目录结构"></a>4.2 文件和树型目录结构</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161911578.png" alt="文件和树型目录结构"></p><blockquote><p>很多操作系统采用树型的目录结构，比如：dos、windows、linux系统都是的。</p></blockquote><ul><li>绝对路径：是从盘符开始的路径</li><li>相对路径：是从当前路径开始的路径</li><li>若当前目录为D1，要求F2路径，则绝对路径：/D1/W2/F2，相对路径：W2/F2</li><li>不仅仅是在计算机中运用了相对路径和绝对路径的表达方式，还有在拨打固定电话，需要加区域号才行</li></ul><p><strong>文件属性</strong></p><ol><li>R只读文件属性</li><li>A存档属性</li><li>S系统文件</li><li>H隐藏文件</li></ol><p><strong>文件名的组成</strong></p><ol><li>驱动器号</li><li>路径</li><li>主文件名</li><li>扩展名</li></ol><h2 id="4-3-空闲存储空间的管理"><a href="#4-3-空闲存储空间的管理" class="headerlink" title="4.3 空闲存储空间的管理"></a>4.3 空闲存储空间的管理</h2><blockquote><p>所谓空闲存储空间就是在磁盘上存在大量的空间，我们需将这些空间管理起来，以便在某一个文件申请一个空间时，能够有依据的分配给他相应的空间</p></blockquote><p>总共有四种管理方法，分别是：空闲区表法(空闲文件目录)、空闲链表法、位示图法、成组链接法。</p><ul><li>空闲区表法:用一个表来记录哪些地方是空闲的，以便将其管理起来</li><li>空闲链表法：把空闲区域都链起来，链成一个链表，然后需要空间分配的时候，从这条链表中划分出一部分出来即可</li><li>成组链接法：分组也分链的方式进行管理</li><li>位示图法(重点)：先画一个位示图，该图当中1表示该区域已被占用，0表示该区域还是空闲的，我们将存储空间分成若干个物理块，就能直观的表达出物理块是否被占用。位示图在生活中应用比较广泛。比如：机舱座位编号图、电影院座位示意图 都是运用了位示图</li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161923164.png" alt=""></p><p>由题意可知，物理块号是从0开始编号的，每一位对于文件存储器上的一个物理块，故有<code>(4195+1)÷32=131⋯4</code>，然后由图可知系统中字的编号是从0开始的，故该物理块由第131号字来描述，而题目是第几个字，编号从1开始，故从第132个字开始描述。我们要占用该物理块，毫无疑问该位置应该取“1”，位置是从第0位开始算的，故系统应该将该字的第3位置取“1”。</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161935426.png" alt=""></p><h1 id="5-设备管理"><a href="#5-设备管理" class="headerlink" title="5 设备管理"></a>5 设备管理</h1><blockquote><p>设备管理的五个层次从上到下依次为：用户进程、与设备无关的系统软件、设备驱动程序、中断处理程序、硬件</p></blockquote><h2 id="5-1-数据传输控制方式"><a href="#5-1-数据传输控制方式" class="headerlink" title="5.1 数据传输控制方式"></a>5.1 数据传输控制方式</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304161939686.png" alt=""></p><p>数据传输控制主要是指内存和外设之间的数据传输问题，解决方案包括程序控制方式、程序中断方式、DMA方式、通道、输入输出处理机。前三种要求重点掌握，后两种一般是运用在特殊的计算机上解决数据传输问题。</p><ol><li>程序控制方式：又称为程序插叙方式，这种方式是最为低级的，也是CPU介入最多的一种方式，即整个数据的传输控制需要CPU的介入。此时外设处于非常被动的地位，即不能主动的反馈信息，比如：是否完成是否中断等信息，而是由CPU发出相应的查询指令，进而对信息进行查询。这种方式存在一些弊端，老板下发任务给员工，而老板每隔一段时间问员工完成没有，最终员工说老早就完成了，这就导致员工的工作效率降低了，故而提出了程序中断方式。</li><li>程序中断方式：大部分与程序控制方式相同，但相较于程序控制方式，添加了中断机制，存在了主动性。即：如果外设完成了数据的传输或发布等操作，外设会发出中断指令，系统就会进行下一步处理，效率比程序控制方式更高</li><li>DMA方式（Direct Memory Access，直接存储器访问）：在该方式中，会有专门的DMA控制器管控外设与内存之间的数据交换过程，CPU只需要在开头进行一些介入，比如安排好事物、做好初始化等等，整个过程都有DMA控制器来完成，完成之后由CPU接管后续的工作，这样的方式效率就会高很多</li></ol><h2 id="5-2-虚设备与SPOOLING技术"><a href="#5-2-虚设备与SPOOLING技术" class="headerlink" title="5.2 虚设备与SPOOLING技术"></a>5.2 虚设备与SPOOLING技术</h2><p>Spooling技术实现独占设备虚拟共享。</p><blockquote><p>用一个实例说明其原理。<br>假设有4个人共用一台打印机，那么这台打印机是放在打印房中，A,B,C,D四个人是在不同的办公室，通过远程方式连接该台打印机，而打印机同一时间只能服务于一个用户，而一个用户远程打印时，提示有人使用，想了想后等待20分钟后再来，提示还是有人使用，这不过碰巧有人使用，实际上外设的利用率降低。这时就提出了Spooling技术，该技术应用非常广泛，比如：打印机和操作系统等等。</p></blockquote><ol><li><p><strong>SPOOLING</strong>技术的应用场景和相应概念：<strong>SPOOLing</strong>是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”。 <strong>SPOOLing</strong>技术通过磁盘实现。</p></li><li><p>对于<strong>SPOOLING</strong>技术的过程：</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304162103631.png" alt=""></p><ul><li>对于多个输入设备</li><li>将输入的任务放到输入缓冲区当中</li><li>以输入进程，输入到输入井</li><li>再从输入井，依次的输出</li></ul></li><li><p>也就是说我们不需要以PV操作检查进程有没有开始，有没有做完，我们都将输入任务放到输入井中，然后从输入井依次输出任务。</p></li></ol><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304162104127.png" alt=""></p><h2 id="5-3-微内核操作系统"><a href="#5-3-微内核操作系统" class="headerlink" title="5.3 微内核操作系统"></a>5.3 微内核操作系统</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304162105210.png" alt=""></p><p>即内核做得更小的操作系统。</p><p><strong>优点</strong>：可靠性、稳定性、安全性。</p><p>操作系统作为核心的系统软件，如果说操作系统出现问题，就会影响到整个系统的正常运行，如果说将操作系统的内核做的小一些，就会降低这种问题发生的概率。为什么？只把最为核心的部分放在内核当中，这样子只有小块部分出现故障才能产生根本性的影响，而原来放在操作系统的内核部分抽出去了，作为其它的外接系统，而这些系统即使出现故障问题，我们只需要去重启这一小块的功能部件东西即可，就能够解决问题。如果把文件系统、图形系统、设备驱动这些东西放在内核之外，假设文件系统崩溃了，对于微内核系统而言没有关系，我就把文件系统重启一下即可，而不用重启整个操作系统。但如果说是单体内核的操作系统，如果其中的系统出现故障了，那么就表现为整个系统出现了故障。比如：XP系统经常出现蓝屏现象。当你把内核缩小了，那么这种概率就大大降低了。<br>微内核操作系统分成用户态和核心态。核心态就是微内核中内核这一块运行的情况。然后用户态就是核心态之外运行的。也就是说用户态这一块出的故障都没有关系，都可以通过一定的处理方式解决，而核心态出现故障就会比较严重，然后用户态和核心态之间会有交互。意思就是普通的东西在用户态这里处理只有到了非常关键的部分(就是和系统内核紧密关联的部分)才回到核心态去处理。</p><p>哪些部分是在核心态，哪些部分是在用户态，请求这一块的情况也要了解。</p><h1 id="6-其它"><a href="#6-其它" class="headerlink" title="6 其它"></a>6 其它</h1><p><strong>磁盘分区</strong>是指将一块容量相对较大的磁盘划分为多块容量相对较小的磁盘，磁盘分区并不删除磁盘上的数据，但一般情况下，磁盘分区后要经过格式化后才能正式使用。</p><p><strong>磁盘格式化</strong>在往磁盘的所有数据区上写零的操作过程，它是一种纯物理操作，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。那么格式化后，磁盘原有的数据被清除。</p><p><strong>磁盘清理</strong>也可以删除计算机上的文件，但它主要用于删除计算机上那些不需要的文件。</p><p><strong>碎片整理</strong>是指通过系统软件或一些专业的磁盘碎片整理软件对计算机磁盘在长期使用过程中产生的碎片和凌乱文件重新整理，以释放出更多可用的存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;软件设计师&gt;-1 计算机组成与体系结构</title>
      <link href="/2023/04/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/04/02/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据的表示"><a href="#1-数据的表示" class="headerlink" title="1 数据的表示"></a>1 数据的表示</h1><h2 id="1-1-进制的转换"><a href="#1-1-进制的转换" class="headerlink" title="1.1 进制的转换"></a>1.1 进制的转换</h2><blockquote><p>R进制转十进制使用按权展开法，其具体操作方式为：将R进制数的每一位数值用R的k次方形式表示，即幂的底数是R，指数为k，k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间数码的个数加1</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021442633.png" alt="例 1-1"></p><blockquote><p>十进制转R进制使用短除法</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021444298.png" alt="例 1-2"></p><blockquote><p>二进制转八进制与十六进制数</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021450055.png" alt="例 1-3"></p><h2 id="1-2-原码反码补码"><a href="#1-2-原码反码补码" class="headerlink" title="1.2 原码反码补码"></a>1.2 原码反码补码</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021500816.png" alt="原码反码补码移码"></p><p>一个字节在计算机中占8个位，二进制表示中最前面的代表符号位，0为正数，1为负数。计算机中二进制只有加法没有减法，所以1-1为0000 0001加上1000 0001等于1000 0010。正数的<code>原码、反码、补码</code><strong>相同</strong>，负数的反码符号位不变，剩余位按位取反，反码加一为补码。因为反码1-1相加结果为-0，所以实际计算时要用补码进行计算。</p><p>移码用于浮点运算中的阶码，补码符号位取反即为移码</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021517899.png" alt="数值表示范围"></p><p>补码的表示范围比原码和反码多，是因为补码正0和负0一致</p><h2 id="1-3-浮点数运算"><a href="#1-3-浮点数运算" class="headerlink" title="1.3 浮点数运算"></a>1.3 浮点数运算</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021524036.png" alt="浮点数运算"></p><h1 id="2-CPU结构"><a href="#2-CPU结构" class="headerlink" title="2 CPU结构"></a>2 CPU结构</h1><h2 id="2-1-运算器与控制器的组成"><a href="#2-1-运算器与控制器的组成" class="headerlink" title="2.1 运算器与控制器的组成"></a>2.1 运算器与控制器的组成</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021540095.png" alt="计算机结构（了解）"></p><h2 id="2-2-计算机体系结构分类-Flynn"><a href="#2-2-计算机体系结构分类-Flynn" class="headerlink" title="2.2 计算机体系结构分类-Flynn"></a>2.2 计算机体系结构分类-Flynn</h2><div class="table-container"><table><thead><tr><th>体系结构类型</th><th>结构</th><th>关键特性</th><th>代表</th></tr></thead><tbody><tr><td>单指令流单数据流SISD</td><td><code>控制部分：一个</code> <code>处理器：一个</code> <code>主控模块：一个</code></td><td></td><td>单处理器系统</td></tr><tr><td>单指令流多数据流SIMD</td><td><code>控制部分：一个</code> <code>处理器：多个</code> <code>主控模块：多个</code></td><td>各处理器以异步的形式执行同一条指令</td><td>并行处理机、阵列处理机、超级向量处理机</td></tr><tr><td>多指令流单数据流MISD</td><td><code>控制部分：多个</code> <code>处理器：一个</code> <code>主控模块：多个</code></td><td>被证明不可能，至少是不实际</td><td>目前没有，有文献称流水线计算机位此类</td></tr><tr><td>多指令流多数据流MIMD</td><td><code>控制部分：多个</code> <code>处理器：多个</code> <code>主控模块：多个</code></td><td>能够实现作业、任务、指令等各级全面并行</td><td>多处理机系统、多计算机</td></tr></tbody></table></div><h2 id="2-3-CISC与RISC"><a href="#2-3-CISC与RISC" class="headerlink" title="2.3 CISC与RISC"></a>2.3 CISC与RISC</h2><div class="table-container"><table><thead><tr><th style="text-align:center">指令系统类型</th><th style="text-align:center">指令</th><th style="text-align:center">寻址方式</th><th style="text-align:center">实现方式</th><th style="text-align:center">其它</th></tr></thead><tbody><tr><td style="text-align:center">CISC（复杂）</td><td style="text-align:center">数量多，使用频率差别大，可变长格式</td><td style="text-align:center">支持多种</td><td style="text-align:center">微程序控制技术（微码）</td><td style="text-align:center">研制周期长</td></tr><tr><td style="text-align:center">RISC（精简）</td><td style="text-align:center">数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存</td><td style="text-align:center">支持方式少</td><td style="text-align:center">增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线</td><td style="text-align:center">优化编译，有效支持高级语言</td></tr></tbody></table></div><h1 id="3-流水线"><a href="#3-流水线" class="headerlink" title="3 流水线"></a>3 流水线</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><blockquote><p>流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021611866.png" alt="流水线"></p><h2 id="3-2-流水线计算"><a href="#3-2-流水线计算" class="headerlink" title="3.2 流水线计算"></a>3.2 流水线计算</h2><blockquote><p>例：若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的时间分别是取指2ns，分析2ns，执行1ns。那么，流水线周期是多少？100条指令全部执行完毕需要的时间是多少？</p></blockquote><ul><li><p>流水线周期为执行时间最长的一段</p></li><li><p>流水线计算公式为：</p><p>1条指令执行时间 + （指令条数 - 1） * 流水线周期</p><ol><li>理论公式： <code>(t1 + t2 +..+ tk) + (n - 1) * ∆t</code></li><li>实践公式： <code>(k + n - 1) * ∆t</code></li></ol></li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021629702.png" alt="切片计算"></p><h2 id="3-3-流水线吞吐率计算"><a href="#3-3-流水线吞吐率计算" class="headerlink" title="3.3 流水线吞吐率计算"></a>3.3 流水线吞吐率计算</h2><blockquote><p>流水线的吞吐率（Though Put rate， TP）是指在单位时间内流水线所完成的任务数量或输出的结果数量。计算流水线吞吐率的最基本的公式如下</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021632795.png" alt="流水线吞吐率"></p><p>流水线最大吞吐率：</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021633920.png" alt="流水线最大吞吐率"></p><h2 id="3-4-流水线的加速比"><a href="#3-4-流水线的加速比" class="headerlink" title="3.4 流水线的加速比"></a>3.4 流水线的加速比</h2><blockquote><p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。计算流水线加速比的基本共识如下</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021636871.png" alt="流水线加速比"></p><h2 id="3-5-流水线的效率"><a href="#3-5-流水线的效率" class="headerlink" title="3.5 流水线的效率"></a>3.5 流水线的效率</h2><blockquote><p>流水线的效率是指流水线的设备利用率。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比</p></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021649734.png" alt="时空图"></p><p>计算流水线效率的公式为：</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021649981.png" alt="流水线效率公式"></p><h1 id="4-存储结构"><a href="#4-存储结构" class="headerlink" title="4 存储结构"></a>4 存储结构</h1><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021656587.png" alt="存储结构"></p><h2 id="4-1-Cache-概念"><a href="#4-1-Cache-概念" class="headerlink" title="4.1 Cache-概念"></a>4.1 Cache-概念</h2><ul><li>Cache的功能：提供CPU数据输入输出的速率，突破冯诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制</li><li>在计算机的存储系统体系中，Cache是访问速度最快的层次</li><li>使用Cache改善系统性能的依据是程序的局部性原理</li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021702528.png" alt="使用Cache+主存储器的平均周期"></p><h2 id="4-2-局部性原理"><a href="#4-2-局部性原理" class="headerlink" title="4.2 局部性原理"></a>4.2 局部性原理</h2><blockquote><ul><li>时间局部性</li><li>空间局部性</li><li>工作集理论：工作集是进程运行时被频繁访问的页面集合</li></ul></blockquote><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021712298.png" alt="时间局部性例子"></p><p>for循环中循环了1000000次，数据直接从cache中取，为时间局部性。</p><p>数组中访问相邻的数据为空间局部性</p><h2 id="4-3-主存"><a href="#4-3-主存" class="headerlink" title="4.3 主存"></a>4.3 主存</h2><h3 id="4-3-1-分类"><a href="#4-3-1-分类" class="headerlink" title="4.3.1 分类"></a>4.3.1 分类</h3><ul><li>随机存取存储器<ul><li>DRAM（Dynamic RAM，动态RAM） -SDRAM</li><li>SRAM（Static RAM，静态）</li></ul></li><li>只读存储器<ul><li>MROM（Mask ROM，掩模式ROM）</li><li>PROM（Programmable ROM，一次可编程ROM）</li><li>EPROM（Erasable PROM，可擦除的PROM）</li><li>闪速存储器（flash memory，闪存）</li></ul></li></ul><h3 id="4-3-2-编址"><a href="#4-3-2-编址" class="headerlink" title="4.3.2 编址"></a>4.3.2 编址</h3><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021746140.png" alt="存储器"></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021746518.png" alt="编址例题"></p><p>第一空地址单元计算方式为<code>(C7FFF+1-AC000)/1024</code>，加1是因为是从0开始计算的，计算结果为112；</p><p>第二空计算方式为<code>(112K * 16) / 28 * 16K * x</code>，x计算结果为4</p><h2 id="4-4-磁盘结构与参数"><a href="#4-4-磁盘结构与参数" class="headerlink" title="4.4 磁盘结构与参数"></a>4.4 磁盘结构与参数</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021753408.png" alt="存取时间"></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021800722.png" alt="例题1"></p><h1 id="5-总线"><a href="#5-总线" class="headerlink" title="5 总线"></a>5 总线</h1><p>概念：总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。根据总线所处的位置不同，总线通常被分为三种类型</p><ol><li>内部总线：微机内部的，各个外围芯片与处理器之间的总线，属于芯片级别</li><li>系统总线：系统总线即为各个插线板和系统板之间的总线，包括<ul><li>数据总线：用来阐述数据的，如32位，64位等一次性能够传输的位</li><li>地址总线：假设该计算机的地址总线为32位，那就代表它的地址空间为2的32次方个字节</li><li>控制总线：发送相应的控制信号的总线</li></ul></li><li>外部总线：即微机和外部设备的总线</li></ol><blockquote><p>总线上的多个部件之间只能分时向总线发送数据，但可以同时从总线接收数据</p></blockquote><h1 id="6-系统可靠性分析与设计"><a href="#6-系统可靠性分析与设计" class="headerlink" title="6 系统可靠性分析与设计"></a>6 系统可靠性分析与设计</h1><p>串联和并联的可靠性的计算以及串联和并联混合的情况</p><h2 id="6-1-串联系统"><a href="#6-1-串联系统" class="headerlink" title="6.1 串联系统"></a>6.1 串联系统</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021903017.png" alt="串联系统模型"></p><p><strong>串联系统的结构</strong>: 只要一个子系统失效，则整个系统都将失效</p><p><strong>串联系统可靠性的计算</strong>：即各个串联子系统可靠性相乘，如上图，其中R为可靠性，此外，1-可靠性即为失效率，而总的失效率即为串联各个部件的失效率作和(近似计算)</p><h2 id="6-2-并联系统"><a href="#6-2-并联系统" class="headerlink" title="6.2 并联系统"></a>6.2 并联系统</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021907714.png" alt="并联系统模型"></p><p><strong>并联系统的结构</strong>：少数子系统的失效将不会影响整个系统。</p><p><strong>并联系统可靠性的计算</strong>：通过计算失效率来求得可靠性，即各个子系统的失效率相乘，再由1减去它，即可得到系统可靠性。上图所示，μ表示可靠率，但是我们一般不使用这种方式求，而是使用1减可靠率即可。</p><h2 id="6-3-N模冗余系统与混合系统"><a href="#6-3-N模冗余系统与混合系统" class="headerlink" title="6.3 N模冗余系统与混合系统"></a>6.3 N模冗余系统与混合系统</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021910661.png" alt="N模冗余系统模型"></p><p>该模型软硬界都有应用。面向一些高可靠性系统的要求时，需要提高系统的可靠性，我们就可以使用N模冗余系统的方式。</p><p>图片解释：数据输入m个子系统中，它们各自得出自己的结果，然后汇总到表决器，表决器将遵循少数服从多数的原则，输出大多数子系统得到的那个答案然后进行输出。</p><p><strong><font color="red" size=5>注：近年来该模型不再考察。</font></strong></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304021912824.png" alt="混合系统模型"></p><h1 id="7-差错控制"><a href="#7-差错控制" class="headerlink" title="7 差错控制"></a>7 差错控制</h1><h2 id="7-1-CRC与海明校验码"><a href="#7-1-CRC与海明校验码" class="headerlink" title="7.1 CRC与海明校验码"></a>7.1 CRC与海明校验码</h2><p>主要是了解校验码的作用，各自的运算特点以及编码解码的过程又是怎么样的。CRC与海明校验码的基本原理和操作流程是要求掌握的。</p><h3 id="7-1-1-检错和纠错"><a href="#7-1-1-检错和纠错" class="headerlink" title="7.1.1 检错和纠错"></a>7.1.1 检错和纠错</h3><p><strong>检错</strong>：将错误检查出来</p><p><strong>纠错</strong>：将错误检查出来的同时并进行纠正</p><p>要达到检错和纠错的目的，往往是需要加冗余信息进行实现。而在编码当中，往往是通过增大码距的方式进行实现。</p><h3 id="7-1-2-码距"><a href="#7-1-2-码距" class="headerlink" title="7.1.2 码距"></a>7.1.2 码距</h3><ul><li><p>码距：指整个编码系统中任意两个码字的最小距离。如A变化X个位得到B，则X就为码距，如：若使用2位长度的二进制编码，若以A=11，B=00为例，A,B之间的最小码距为2</p></li><li><p>作用：增大码距能够起到检错的作用，因为数据在传输的过程中如果链路出现了问题，那么将会使得接收到的二进制数发生变化，若码距过小，则很可能造成信息的混淆，增大码距就使得被改变的二进制数混淆信息的概率极大的降低；若码距再进行增大，则能够起到纠错的作用，因为数据链路出错的概率比较低，只能造成传输中极少二进制数的改变，我们可以根据该传输失真的二进制中大部分二进制数的构成来进行判断，推断出结果就达到了纠错的目的</p></li></ul><p>例如：</p><blockquote><p>若用 1 位长度的二进制编码。若 A=1,B=0 。这样 A,B 之间的最小码距为 1 。<br>若用 2 位长度的二进制编码, 若以 A=11,B=00 为例, A、B 之间的最小码距为 2 。<br>若用 3 位长度的二进制编码, 可选用 111,000 作为合法编码。 A,B 之间的最小码距为 3 。 </p></blockquote><h3 id="7-1-3-码距与检错、纠错的关系"><a href="#7-1-3-码距与检错、纠错的关系" class="headerlink" title="7.1.3 码距与检错、纠错的关系"></a>7.1.3 码距与检错、纠错的关系</h3><ul><li>在一个码组内为了检测e个误码，要求最小码距d应满足：d&gt;=e+1</li><li>在一个码组内为了纠正t个误码，要求最小码距d应该满足：d&gt;=2t+1</li></ul><h3 id="7-1-4-模2除法"><a href="#7-1-4-模2除法" class="headerlink" title="7.1.4 模2除法"></a>7.1.4 模2除法</h3><blockquote><p>模2除法是指在做除法运算的过程中不计其进位的除法，也就是进行异或操作。</p></blockquote><p>例如，10111对110进行模2除法为：</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/image-20230405182443145.png" alt="模2除法"></p><h3 id="7-1-5-循环校验码CRC"><a href="#7-1-5-循环校验码CRC" class="headerlink" title="7.1.5 循环校验码CRC"></a>7.1.5 循环校验码CRC</h3><p>这是一种可以检错但不能纠错的编码</p><p>CRC的原理：在原始报文后面添加校验信息，然后让其与循环校验码的生成多项式进行模2运算，余数添加到原始报文后面，这时的原始报文就是CRC。然后拿循环校验码的生成多项式与CRC进行模2运算余数为0，说明传输过程不会出现错误。若不为0则说明传输过程出现了错误。</p><p>注：生成多项式是一个二进制数，如”X^4+X^3+X+1”，这个生成多项式实际上就是二进制数11011；在与原始报文相除时，需在原码后方添加一些0，添加的0的个数等于生成多项式的二进制位数减去1，增加的0即为<strong>校验信息</strong></p><p>例:原始报文为“11001010101”,其生成多项式为:”X^4+X^3+X+1”。对其进行CRC编码后的结果为11001010101<strong>0011</strong></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/image-20230405183211211.png" alt="例子"></p><h3 id="7-1-6-奇偶校验码"><a href="#7-1-6-奇偶校验码" class="headerlink" title="7.1.6 奇偶校验码"></a>7.1.6 奇偶校验码</h3><blockquote><p>定义：奇偶码（Parity Check）跟前面提到过的CRC校验码一样，奇偶校验码也是一种校验码，它用来检测数据传输过程中是否发生错误，是众多校验码中最为简单的一种。</p></blockquote><p>顾名思义，它有两种验证方式：</p><ul><li>奇校验：原始码流+校验位 总共有奇数个1</li><li>偶校验：原始码流+校验位 总共有偶数个1</li></ul><p>跟CRC类似，也是在原始码流后面加上校验位。不同的是，它的校验位只有1位，要么是0，要么是1，并且它的校验码还可以放在码流的前面。</p><p>例如下图有5组原始码，校验位的计算方式如下。红色代表校验位。补充0或者1将校验码满足奇数个1或者偶数个1。</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/image-20230405183934702.png" alt=""></p><p>例如：我们存在一套原始码为：00，01，10，11，在这套编码中至少有一个数字不相同，我们称这套编码的码距为1。如果采用奇偶校验的方法，我们至多可以将一组编码的码距提升1，如上的例子就可以将码距提升为2。</p><p>以偶验证为例：上述编码可以写成：000，011，101，110，这样做的主要目的是将原来可以表示十进制0~3的数，扩大到0~7.而0~7这8个数中只有4个数是正确的，那么就是说只要出现了另外的4个数就说明数据出错了。</p><p>但是奇偶校验只能检测出数据是否出错，而不能检测出哪一位出错，例如收到数据111，我们无法判断究竟是由011，101，110，这三者中的哪一个变来的，为了解决这一问题，就提出海明校验码。</p><h3 id="7-1-7-海明校验码"><a href="#7-1-7-海明校验码" class="headerlink" title="7.1.7 海明校验码"></a>7.1.7 海明校验码</h3><p>定义：海明码（<strong>Hamming Code</strong>）是利用奇偶性来检错和纠错的校验方法。海明码的构成方法是在数据位之间的确定位置插入<strong>k个校验位</strong>，通过扩大码距来实现检错和纠错。对于<strong>数据位n</strong>的数据，加入k位的校验码，它应满足：</p><script type="math/tex; mode=display">2^{k} - 1 >= n + k</script><p>这个式子的意思是，可以用来检验错误的数据个数（2^k - 1）要大于或等于原数据位数（n）和校验位数（k）的和。显然在2的k次方中我们要留出一个数表示数据正确，所以我们用2^k - 1来表示出错的位数</p><p>理解了公式之后我们通过一个例子来学习一下海明码到底怎么用。</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304022103689.png" alt="例：求信息1011的海明码"></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304022104194.png" alt="(1)"></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%BD%AF%E8%80%83/202304022104553.png" alt="(2)"></p><p>综上所述，二进制100的十进制就是4，故说明第4位错误。那么我们将第4位取反即可得到正确的数据。</p><font color="red" size=5>注：其实就是拿算好的海明码中的校验码与收到信息的校验码的位数做异或操作。</font><h1 id="8-可靠性"><a href="#8-可靠性" class="headerlink" title="8 可靠性"></a>8 可靠性</h1><p><strong>可用性</strong>是指在给定的时间点上，一个系统能够正确运作的效率</p><p><strong>可靠性</strong>是指系统在给定的时间间隔内，给定条件下无失效运作的概率</p><p>MTBF为平均失效间隔时间，则可用性用MTBF (1 + MTBF)表示。<br>MTTF为平均无故障时间，则可靠性用MTTF(1+MTTF)表示。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Flowable&gt;-1 基础</title>
      <link href="/2023/03/26/Flowable%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/26/Flowable%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是工作流"><a href="#1-什么是工作流" class="headerlink" title="1 什么是工作流"></a>1 什么是工作流</h1><blockquote><p>工作流，是把业务之间的各个步骤以及规则进行抽象和概括性的描述。使用特定的语言为业务流程建模，让其运行在计算机上，并让计算机进行计算和推动</p></blockquote><p><strong>工作流是复杂版本的状态机</strong></p><p>工作流解决的痛点在于，解除业务宏观流程和微观逻辑的耦合，让熟悉宏观业务流程的人去制定整套流转逻辑，而让专业的人只需要关心他们应当关心的流程节点，就好比大家要一起修建一座超级体育场，路人甲只需要关心他身边的这一堆砖是怎么堆砌而非整座建筑。</p><p><strong>那么工作流有什么不能解决的问题呢？</strong></p><p>工作流是一个固定好的框架，大家就按照这个框架来执行流程就行了，但某些情况他本身没有流转顺序的要求，比如：小明每天需要做作业、做运动以及玩游戏，它们之间没有关联性无法建立流程，但可以根据每一项完成的状态决定今天的任务是否完结，这种情况我们需要使用CMMN来建模，它就是专门针对这种情况而设计的。</p><h1 id="2-BPMN2-0协议"><a href="#2-BPMN2-0协议" class="headerlink" title="2 BPMN2.0协议"></a>2 BPMN2.0协议</h1><blockquote><p>对于业务建模，我们需要一种通用的语言来描绘，这样在沟通上和实现上会降低难度，就像中文、英文一样，BPMN2.0便是一种国际通用的建模语言，他能让自然人轻松阅读，更能被计算机所解析。</p></blockquote><p>协议中元素的主要分类为，<code>事件-任务-连线-网关</code>。</p><p>一个流程必须包含一个事件（如：开始事件）和至少一个结束（事件）。其中网关的作用是流程流转逻辑的控制。任务则分很多类型，他们各司其职，所有节点均由连线联系起来。</p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E/202303261620791.jpg" alt="汽车生产流程模型"></p><p>这里是一个生产汽车的流程，从“汽车设计”节点到“批准生产”节点是一个穿行的任务，而审批的结果会遇到一个互斥网关，上面讲过，互斥网关只需要满足其中一个条件就会流转，而这里表达的意义就是审批是否通过。“载入图纸”是一个服务任务，它是自动执行的，之后会卡在“等待原材料”这个节点，因为这个节点是需要人为去判断（比如原材料涨价，原材料不足等因素），所以需要在一种自定义的条件下Trigger，而该图的条件应该为“原材料足够”，原材料足够之后，我们会开始并行生产汽车零件。</p><h1 id="3-流程引擎对比"><a href="#3-流程引擎对比" class="headerlink" title="3 流程引擎对比"></a>3 流程引擎对比</h1><blockquote><p>Flowable是BPMN2.0协议的一种Java版本的实现。</p></blockquote><p>Flowable项目提供了一组核心的开源业务流程引擎，这些引擎紧凑且高效。它们为开发人员、系统管理员和业务用户提供了一个工作流和业务流程管理（BPM）平台。它的核心是一个非常快速且经过测试的动态BPMN流程引擎。它基于Apache2.0开源协议，有稳定且经过认证的社区。</p><p>Flowable可以嵌入Java应用程序中运行，也可以作为服务器、集群运行，更可以提供云服务。</p><p>与大多数故事一样，Flowable也是因为其与Activiti对未来规划的路线不认同而开辟了一条自己的道路。目前主流的工作流开源框架就是Activiti/Camunda/Flowable，它们都有一个共同的祖先jbpm。先是有了jbpm4，随后出来了一个Activiti5，Activiti5经过一段时间的发展，核心人员出现分歧，又分出来了一个Camunda。activiti5发展了4年左右，紧接着就出现了Flowable。</p><p>相比于Activiti，Flowable的核心思想更像是在做一个多彩的工具，它在工作流的基础功能上，提供了很多其他的扩展，使用者可以随心所欲地把Flowable打造成自己想要的样子。例如：Camel节点，Mule节点。他不仅有bpmn引擎，还有cmmn（案例管理模型），dmn（决策模型），content（内容管理），form（表单管理），idm（用户鉴权）等等，但这也间接导致了Flowable的包结构非常繁多，上手非常困难。</p><p>而Activiti则只着重于处理bpmn，它的方向在于云，他的设计会尽量像例如Spring Cloud、Docker、K8S靠拢。</p><p>如果你单纯地想快速上手bpmn引擎，建议使用Activiti，如果你想做出花样繁多的工作流引擎，建议使用Flowable。</p><p>而Camunda（卡蒙达）则更加的轻巧灵活，他的初衷就是为开发人员设计的“小工具”，但我个人的感觉而言，Camunda从代码上看并没有Activiti和Flowable好，而且他的社区是最不活跃的一个（至少从国内的角度来看），所以不太建议使用（当然这带了很多个人主观感受，如有不同意见，欢迎讨论）。</p><h1 id="4-创建流程引擎"><a href="#4-创建流程引擎" class="headerlink" title="4 创建流程引擎"></a>4 创建流程引擎</h1><p>我们将构建的例子是一个简单的<em>请假(holiday request)</em>流程：</p><ul><li><em>雇员(employee)</em>申请几天的假期</li><li><em>经理(manager)</em>批准或驳回申请</li><li>我们会模拟将申请注册到某个外部系统，并给雇员发送结果邮件</li></ul><p><a href="https://tkjohn.github.io/flowable-userguide/#getting.started.command.line">请参考Flowable BPMN用户手册</a></p>]]></content>
      
      
      <categories>
          
          <category> 流程引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flowable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-10 异常</title>
      <link href="/2023/03/25/Java-%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/03/25/Java-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”（开发过程中的语法错误和逻辑错误不是异常）</p><p>这些 异常事件 可分为两类：</p><ul><li><p>Error（错误）：Java 虚拟机无法解决的严重问题。</p><p>如：JVM 系统内部错误，资源耗尽等严重情况。Error 是严重错误，程序会崩溃。</p></li><li><p>Exception：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。</p><p>如：空指针访问，试图读取不存在的文件，网络中断等等。</p><p>Exception 又分为两大类：</p><ul><li>运行时异常（程序运行时，发生的异常）</li><li>编译时异常（编程时，编译器检查出的异常）</li></ul></li></ul></blockquote><h1 id="1-常见的运行与编译异常"><a href="#1-常见的运行与编译异常" class="headerlink" title="1 常见的运行与编译异常"></a>1 常见的运行与编译异常</h1><blockquote><p>常见的运行时异常（runtimeException）包括</p><ul><li>NullPointerException：空指针异常</li><li>ArithmeticException：数学运算异常</li><li>ArrayIndexOutOfBoundsException：数组下标越界异常</li><li>ClassCastException：类型转换异常</li><li>NumberFormatException：数学格式异常</li></ul></blockquote><h2 id="1-1-空指针异常"><a href="#1-1-空指针异常" class="headerlink" title="1.1 空指针异常"></a>1.1 空指针异常</h2><p>当应用程序试图在需要对象的地方使用 null 时，抛出该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length;<span class="comment">//这里，出现了 空指针异常</span></span><br></pre></td></tr></table></figure><h2 id="1-2-数学运算异常"><a href="#1-2-数学运算异常" class="headerlink" title="1.2 数学运算异常"></a>1.2 数学运算异常</h2><p>当出现异常的运算条件时，抛出该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span> / <span class="number">0</span>;<span class="comment">//这里，出现了 数学运算异常</span></span><br></pre></td></tr></table></figure><h2 id="1-3-数组下标越界异常"><a href="#1-3-数组下标越界异常" class="headerlink" title="1.3 数组下标越界异常"></a>1.3 数组下标越界异常</h2><p>用非法索引（为负或超出范围）访问数组时，抛出该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">nums[-<span class="number">50</span>] = <span class="number">100</span>;<span class="comment">//这里，出现了 数组下标越界异常</span></span><br></pre></td></tr></table></figure><h2 id="1-4-类型转换异常"><a href="#1-4-类型转换异常" class="headerlink" title="1.4 类型转换异常"></a>1.4 类型转换异常</h2><p>当试图把对象强制转换为不是实例的子类时，抛出该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A1</span>();</span><br><span class="line">        <span class="type">A2</span> <span class="variable">a1</span> <span class="operator">=</span> (A2)a1;<span class="comment">//这里，出现了 类型转换异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-数字格式不正确异常"><a href="#1-5-数字格式不正确异常" class="headerlink" title="1.5 数字格式不正确异常"></a>1.5 数字格式不正确异常</h2><p>当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//这里，出现了 数字格式不正确异常</span></span><br></pre></td></tr></table></figure><h2 id="1-6-常见的编译异常"><a href="#1-6-常见的编译异常" class="headerlink" title="1.6 常见的编译异常"></a>1.6 常见的编译异常</h2><blockquote><ul><li>SQLException：操作数据库时，查询表可能发生异常</li><li>IOException：操作文件时，发生的异常</li><li>FileNotFoundException：操作一个不存在的文件时，发生的异常</li><li>ClassNotFoundException：加载类，而该类不存在时，发生的异常</li><li>EOFException：操作文件，到文档末尾，发生的异常</li><li>IllegalArguementException：参数异常</li></ul></blockquote><h1 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2 异常处理"></a>2 异常处理</h1><p>异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是 <code>throws</code></p><ul><li><code>try - chatch - finally</code>：程序员在代码中捕获发生的异常，自行处理</li><li><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是 JVM</li></ul><h2 id="2-1-try-catch-异常处理"><a href="#2-1-try-catch-异常处理" class="headerlink" title="2.1 try - catch 异常处理"></a>2.1 <code>try - catch</code> 异常处理</h2><p>Java 提供 try 和 catch 块 来处理异常。try 块用于包含可能出错的代码，catch 块用于处理 try 块中的异常。可以根据需要在程序中有多个 <code>try - catch</code> 块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//可疑代码</span></span><br><span class="line"><span class="comment">//将异常生成对应的异常对象，传递给 catch 块</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"><span class="comment">//如果发生异常，执行这些代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//无论是否异常，都执行这些代码</span></span><br><span class="line">    <span class="comment">//finally 块可以不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快捷键：选中代码后按 <code>ctrl + alt + T</code></p><h3 id="2-1-1-使用细节"><a href="#2-1-1-使用细节" class="headerlink" title="2.1.1 使用细节"></a>2.1.1 使用细节</h3><ol><li><p>如果异常发生了，则异常发生后面的代码块都不执行，直接进入 catch 块</p></li><li><p>如果异常未发生，则顺序执行 try 代码块，catch 块不执行</p></li><li><p>如果希望不管是否异常，都执行一些代码，则使用 finally</p></li><li><p>可以有多个 catch 捕获不同的异常。要求 子类异常在前，父类异常在后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以进行 try - finally 配合使用（不写 catch）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。</p><p>应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p></li><li><p>如果没有出现异常，执行 try 中所有语句，不执行 catch 语句，最后执行 finally 语句</p></li><li><p>如果出现异常，则 try 块异常发生后，剩余语句不执行。之后执行 catch 语句，最后，执行 finally 语句。</p></li></ol><h2 id="2-2-throws-异常处理"><a href="#2-2-throws-异常处理" class="headerlink" title="2.2 throws 异常处理"></a>2.2 <code>throws</code> 异常处理</h2><p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理</p><p>在方法中声明 <code>throws</code> 语句可以声明抛出异常的列表。<code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metord</span><span class="params">()</span> <span class="keyword">throws</span> FileNontFoundException ,NullPointerException &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-使用细节"><a href="#2-2-1-使用细节" class="headerlink" title="2.2.1 使用细节"></a>2.2.1 使用细节</h3><ol><li>对于 <strong>编译异常</strong>，程序中必须处理。</li><li>对于 <strong>运行异常</strong>，程序中诺没有处理，默认处理是 <code>throws</code></li><li>子类 重写 父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。</li><li>如果有 <code>try - catch</code> 就不必 <code>throws</code> 了</li></ol><h1 id="3-自定义异常"><a href="#3-自定义异常" class="headerlink" title="3 自定义异常"></a>3 自定义异常</h1><blockquote><p>当程序中出现了某些 “错误”，但该信息并未在 <code>Throwable</code> 子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息</p></blockquote><ol><li>定义类：自定义异常类名，继承 RuntimeException 或 Exception</li><li>如果继承 Exception，属于 编译异常。</li><li>如果继承 RuntimeException，属于 运行异常。（一般来说，选这个。这样利用了默认处理机制，更方便）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Metords</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;不能大于100&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-throw-和-throws"><a href="#3-1-throw-和-throws" class="headerlink" title="3.1 throw 和 throws"></a>3.1 <code>throw</code> 和 <code>throws</code></h2><div class="table-container"><table><thead><tr><th>意义</th><th>位置</th><th>后面跟的东西</th><th></th></tr></thead><tbody><tr><td><code>throws</code></td><td>异常处理的一种方式</td><td>方法声明时</td><td>异常类型</td></tr><tr><td><code>throw</code></td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table></div><h2 id="3-2-编程小技巧"><a href="#3-2-编程小技巧" class="headerlink" title="3.2 编程小技巧"></a>3.2 编程小技巧</h2><p>老韩曰：编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-9 枚举和注解</title>
      <link href="/2023/03/20/Java-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/03/20/Java-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1 枚举"></a>1 枚举</h1><p>把具体的对象一一列举出来的类，就称为 枚举类（enumeration）</p><p>实现方法：</p><ol><li>自定义枚举</li><li><code>enum</code> 关键字枚举</li></ol><h2 id="1-1-自定义枚举"><a href="#1-1-自定义枚举" class="headerlink" title="1.1 自定义枚举"></a>1.1 自定义枚举</h2><ol><li>构造器私有化</li><li>去掉 set 方法（可保留 get），防止属性被修改。因为枚举对象值通常为只读</li><li>在类内部直接创建固定对象。使用 <code>final</code> + <code>static</code> 共同修饰，对象名通常全部大写</li><li>枚举对象按照需要可以有多个属性</li></ol><h2 id="1-2-enum关键字"><a href="#1-2-enum关键字" class="headerlink" title="1.2 enum关键字"></a>1.2 <code>enum</code>关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"> RED(<span class="string">&quot;小红&quot;</span>, <span class="number">10</span>), BLUE(<span class="string">&quot;小蓝&quot;</span>, <span class="number">11</span>), YELLOW; <span class="comment">//这句话要放在前面，第三个是无参</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Example</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">     <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用关键字 <code>enum</code> 替代 <code>class</code></li><li>用 <code>常量名.(形参列表);</code> 代替创建对象（放在前面），多个对象的场合用 <code>,</code> 间隔。</li><li>如果使用 <code>enum</code> 枚举，要求将常量对象写在前面</li></ol><h3 id="1-2-1-使用细节"><a href="#1-2-1-使用细节" class="headerlink" title="1.2.1 使用细节"></a>1.2.1 使用细节</h3><ol><li><p>当我们用 <code>enum</code> 关键字开发一个枚举类时，默认会继承 java.lang.Enum 类，而且是一个 <code>final</code> 类。</p><p>这样，我们就能使用 Enum 中的相关方法。</p><p><strong>也正因为如此，<code>enum</code> 类不能继承其他类，亦不能被其它类继承</strong></p><p>不过，<code>enum</code> 类和其他类一样，可以实现接口。</p></li><li><p>传统的 <code>public ststic final RED(&quot;小红&quot;, 10);</code> 简化为 <code>RED(&quot;小红&quot;, 10);</code></p></li><li><p>如果使用无参构造器创建枚举对象，则 实参列表 和 <code>( )</code> 都能省略</p></li></ol><h3 id="1-2-2-Enum-类中的常用方法"><a href="#1-2-2-Enum-类中的常用方法" class="headerlink" title="1.2.2 Enum 类中的常用方法"></a>1.2.2 <code>Enum</code> 类中的常用方法</h3><ul><li><code>valueOf</code>：将字符串转换成枚举对象。要求字符串必须是已有的常量名，否则报异常</li><li><code>values</code>：返回一个数组 <code>Example[]</code>，其中包含定义的所有枚举对象</li><li><code>getDeclaringClass</code>：得到枚举常量所属的 <code>class</code></li><li><code>name</code>：得到当前枚举常量的名称。建议优先用 <code>toString</code></li><li><code>ordinal</code>：输出该枚举对象的次序/编号（从 0 开始编号。如上例 <code>BLUE.ordinal = 1</code>）</li><li><code>compareTo</code>：比较两个枚举常量的编号（调用常量编号 减去 传入常量编号）</li><li><code>clone</code>：枚举类不能 <code>clone</code>，所以，这是一个只会抛出异常的方法</li></ul><h1 id="2-注解"><a href="#2-注解" class="headerlink" title="2 注解"></a>2 注解</h1><blockquote><p>注解（Annotation）也被称为元数据（Metadata）。用于修饰 包、类、方法、属性、构造器、局部变量 等数据信息</p><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p></blockquote><p>在 JavaSE 中，注解的使用目的比较简单，例如 标记过时的功能，忽略警告 等。在 JavaEE 中注解占据了更重要的角色，例如用于配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。</p><ol><li>使用 <code>@Annotation</code> 时要在前面增加 <code>@</code> 符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</li><li>三个基本的 <code>@Annotation</code>：<ul><li><code>@Override</code>：限定某个方法，是 重写 父类方法。该注解只能用于方法。如果你写了该注解，编译器会替你校验，看看是不是真的 重写 了父类方法。</li><li><code>@Deprecated</code>：用于表示某个程序元素（类、方法等）已经过时</li><li><code>@SuppressWarnings()</code>：抑制编辑器警告</li></ul></li><li>如果发现 <code>public @interface XXX&#123;&#125;</code> 这种东西，说明是定义了一个注解类 <code>XXX</code>。这里的 <code>@interface</code> 不代表接口（<code>interface</code>）。</li></ol><h2 id="2-1-Override"><a href="#2-1-Override" class="headerlink" title="2.1 @Override"></a>2.1 <code>@Override</code></h2><ol><li><code>@Override</code> 表示指定重写父类的方法（从编译器层面验证），如果父类没有该方法，就报错</li><li>不写该注解，重写依然构成重写</li><li><code>@Override</code> 只能修饰方法，不能修饰其他 类、包、属性等</li><li>查看 <code>@Override</code> 注解源码为 <code>@Target(ElementType.METHOD)</code> 说明只能修饰方法</li><li><code>@Target</code> 是修饰注解的注解，称为 元注解</li></ol><h2 id="2-2-Deprecated"><a href="#2-2-Deprecated" class="headerlink" title="2.2 @Deprecated"></a>2.2 <code>@Deprecated</code></h2><ol><li><p><code>@Deprecated</code> 表示指定的某个程序元素（类、方法等）已过时</p></li><li><p>不推荐使用，但仍能使用</p></li><li><p>可以修饰方法、类、字段、包、参数</p><p><code>@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</code></p></li><li><p><code>@Deprecated</code> 可以做到新旧版本的兼容和过度</p></li></ol><h2 id="2-3-SuppressWarnings"><a href="#2-3-SuppressWarnings" class="headerlink" title="2.3 @SuppressWarnings()"></a>2.3 <code>@SuppressWarnings()</code></h2><ol><li><p>当我们不想看到警告信息时，用 <code>@SuppressWarnings()</code></p><p>语法：<code>@SuppressWarnings(&#123;&quot;...&quot;&#125;)</code></p><p>在后面 <code>(&#123;&quot;unused&quot;, &quot;unchecked&quot;&#125;)</code> 这样写入你希望抑制的信息，以下是所有可以输入的关键字</p><p>| <strong>关键字</strong>               | <strong>用途</strong>                                           |<br>| :———————————- | :————————————————————————- |<br>| all                      | 抑制所有警告                                       |<br>| boxing                   | 抑制与装箱/解装箱操作相关的警告                    |<br>| cast                     | 抑制与强制转换操作相关的警告                       |<br>| dep-ann                  | 抑制与已弃用注释相关的警告                         |<br>| deprecation              | 抑制与弃用有关的警告                               |<br>| fallthrough              | 抑制与 switch 语句中丢失断点相关的警告             |<br>| finally                  | 抑制不返回的 finally 块的相关警告                  |<br>| hiding                   | 抑制与隐藏变量的局部变量相关的警告                 |<br>| incomplete-switch        | 抑制与 switch 语句中缺少条目相关的警告（enum）     |<br>| nls                      | 抑制与 非nls 字符串字面值相关的警告                |<br>| null                     | 抑制相对于null分析的警告                           |<br>| rawtypes                 | 在类参数上使用泛型时，抑制与非特定类型相关的警告   |<br>| restriction              | 抑制与不推荐或禁止引用有关的警告                   |<br>| serial                   | 抑制与可序列化类缺少serialVersionUID字段相关的警告 |<br>| static-access            | 抑制与不正确的静态访问有关的警告                   |<br>| synthetic-access         | 抑制与未优化的内部类访问相关的警告                 |<br>| unchecked                | 抑制与未检查的操作相关的警告                       |<br>| unqualified-field-access | 抑制与字段访问不合格相关的警告                     |<br>| unused                   | 抑制与未使用代码相关的警告                         |</p></li><li><p><code>@SuppressWarnings</code> 的范围与你放置的位置相关</p></li></ol><h2 id="2-4-JDK-的元注解（了解即可）"><a href="#2-4-JDK-的元注解（了解即可）" class="headerlink" title="2.4 JDK 的元注解（了解即可）"></a>2.4 JDK 的元注解（了解即可）</h2><blockquote><p>JDK 的 元注解 是用于修饰其他注解的注解</p></blockquote><ol><li><p><code>@Rentention</code>：指定注解的作用范围，有三种范围<code>SOURCE</code> <code>CLASS</code> <code>RUNTIME</code></p><p><code>@Rentention</code> 的三种值：</p><ul><li><code>RententionPolicy.SOURCE</code>：编译器使用后，直接丢弃这种策略的注释</li><li><code>RententionPolicy.CLASS</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时， JVM 不会保留注释。这是默认值</li><li><code>RententionPolicy.RUNTIME</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解</li></ul></li><li><p><code>@Target</code>：指定注解的使用范围</p><p><code>@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</code></p></li><li><p><code>@Documented</code>：指定该注解会不会在 Javadoc 体现</p></li><li><p><code>@Inherited</code>：子类会继承父类注解</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-8 面向对象编程（高级）</title>
      <link href="/2023/03/18/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/"/>
      <url>/2023/03/18/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类变量和类方法"><a href="#1-类变量和类方法" class="headerlink" title="1 类变量和类方法"></a>1 类变量和类方法</h1><h2 id="1-1-类变量"><a href="#1-1-类变量" class="headerlink" title="1.1 类变量"></a>1.1 类变量</h2><blockquote><p>类变量：也叫 静态变量/静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。</p><p>语法（推荐）：<code>访问修饰符 static 数据类型 变量名;</code></p><p>或者也可以：<code>static 访问修饰符 数据类型 变量名;</code></p><p>根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中。</p></blockquote><ol><li><p>什么时候需要用类变量：</p><p>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p></li><li><p>类变量 与 实例变量（普通属性）的区别：</p><p>类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的</p></li><li><p>加上 <code>static</code> 称为 类变量 或 静态变量。否则称为 实例变量/普通变量/非静态变量</p></li><li><p>静态变量 可以通过 <code>类名.类变量名;</code> 或 <code>对象名.类变量名;</code> 来访问。但 Java 设计者推荐我们用 <code>类名.类变量名;</code> 来访问。（需满足访问权限和范围）</p></li><li><p>类变量 是在加载类时就初始化了。所以，没有创建对象实例也能访问。</p></li><li><p>类变量 的生命周期是随着 类的加载 开始，随着 类的消亡 而销毁。</p></li><li><p>特别地：<strong>一个 null 对象也可以访问静态变量 / 静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">met</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(t.n);<span class="comment">//这样不会报错</span></span><br><span class="line">        t.met();<span class="comment">//这样也不会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2-类方法"><a href="#1-2-类方法" class="headerlink" title="1.2 类方法"></a>1.2 类方法</h2><blockquote><p>当方法使用 <code>static</code> 修饰后，就是 静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。</p></blockquote><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在 方法区。</li><li>类方法中不允许使用和对象有关的关键字。所以，类方法没有 <code>this</code> 或 <code>super</code></li><li>类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。</li><li>类方法 中只能访问 类变量 或 类方法</li><li>普通方法既可以访问普通方法也可以访问类方法</li></ol><h1 id="2-理解main方法语法"><a href="#2-理解main方法语法" class="headerlink" title="2 理解main方法语法"></a>2 理解<code>main</code>方法语法</h1><blockquote><p><code>public static void main(String[] args)&#123;...&#125;</code></p></blockquote><ol><li><p><code>main</code> 方法 是 JVM 调用的方法。所以该方法的 访问权限 必须为 <code>public</code></p></li><li><p>JVM 在执行 <code>main</code> 方法时不必创建对象，所以 <code>main</code>方法 必须为 <code>static</code></p></li><li><p>该方法接收 <code>String</code> 类型的数组参数。该数组中保存执行 Java 命令 时传递给所运行的类的参数。</p><blockquote><p>工作台中：<code>javac 执行的程序.java</code></p><p><code>java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) ..</code></p><p><a href="https://www.bilibili.com/video/BV1fh411y7R8?p=385&amp;t=129.5">IDEA中怎么做？</a></p></blockquote></li><li><p>在 <code>main</code> 方法 中，我们可以直接调用 <code>main</code> 方法 所在类的静态方法或静态属性。</p><p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员。</p></li></ol><h1 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3 代码块"></a>3 代码块</h1><blockquote><p>代码块：又称为 初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过 <code>&#123; &#125;</code> 包围起来。</p><p>和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类 显式调用，而是加载类时，或创建对象时 隐式调用。</p><p>语法：<code>[修饰符]&#123;代码&#125;;</code></p></blockquote><ol><li>修饰符 是可选项，可不写。要写的话，只能写 <code>static</code></li><li>代码块分为两类：<ul><li>静态代码块：有 <code>static</code></li><li>普通代码块：无 <code>static</code></li></ul></li><li>逻辑语句可以为任意的逻辑语句。</li><li><code>;</code> 可以写，也可以省略。建议写上。</li><li>代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作</li><li>如果多个构造器中都有重复语句，就可以抽取到初始化块中，提高代码复用率。这样，不管用哪个构造器，都会执行代码块。</li></ol><h2 id="3-1-使用细节"><a href="#3-1-使用细节" class="headerlink" title="3.1 使用细节"></a>3.1 使用细节</h2><ol><li><p><code>static</code> 代码块：作用是对类进行初始化。<strong>随着 类的加载 会且只会执行一次</strong>。相对的：普通代码块每创建一个对象就执行一次。</p><ul><li><strong>类什么时候被加载？</strong><ul><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会加载</li><li>使用类的静态成员时（父类也会加载）</li></ul></li></ul><p>以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。</p></li><li><p>创建一个对象时，在 <strong>一个类里</strong> 调用顺序是：</p><ul><li>调用静态代码块 和 静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。</li><li>调用普通代码块 和 普通属性初始化。这两者优先级也相同。</li><li>调用构造器。</li></ul></li><li><p><code>构造器</code> 的最前面其实隐含了 <code>super();</code> 和 <code>调用普通代码块</code>。而静态相关的代码块，属性初始化，在类加载时就执行完毕了。</p><p>这样，创建一个对象时，在 <strong>有继承关系的多个类里</strong> 调用顺序是：</p><ol><li>父类 静态代码块 和 静态初始化</li><li>子类 静态代码块 和 静态初始化</li><li>父类 普通代码块 和 普通初始化</li><li>父类 构造器</li><li>子类 普通代码块 和 普通初始化</li><li>子类 构造器</li></ol></li><li><p>静态代码块 只能调用 静态成员。普通代码块 能调用 任意成员。</p></li></ol><h1 id="4-单例设计模式"><a href="#4-单例设计模式" class="headerlink" title="4 单例设计模式"></a>4 单例设计模式</h1><blockquote><p>什么是设计模式：设计模式是在大量的实践中总结和理论化后优选的代码结构、编程风格、解决问题的思考方式。设计模式就像是经典的棋谱，免去我们自己再思考和摸索。</p></blockquote><p>单例设计模式：采取一定的方法，保证再整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p><h2 id="4-1-应用实例"><a href="#4-1-应用实例" class="headerlink" title="4.1 应用实例"></a>4.1 应用实例</h2><blockquote><p>后面会学更多，这里先展示两种：饿汉式、懒汉式</p></blockquote><h3 id="4-1-1-饿汉式"><a href="#4-1-1-饿汉式" class="headerlink" title="4.1.1 饿汉式"></a>4.1.1 饿汉式</h3><p>步骤如下：</p><ol><li><p>构造器私有化（防止用户直接 new）</p></li><li><p>类的内部创建对象</p></li><li><p>向外暴露一个静态的公共方法</p></li><li><p>代码实现</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GF</span>&#123;</span><br><span class="line">       <span class="keyword">private</span> String name;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GF</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GF</span>(<span class="string">&quot;萝茵&quot;</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">GF</span><span class="params">(String name)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> GF <span class="title function_">getGF</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> gf;</span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象，通常都是重量级的对象</p><p>有时，我们用不到这个创建的对象，那个场合，会造成资源浪费。</p></blockquote></li></ol><h3 id="4-1-2-懒汉式"><a href="#4-1-2-懒汉式" class="headerlink" title="4.1.2 懒汉式"></a>4.1.2 懒汉式</h3><p>步骤如下：</p><ol><li><p>构造器私有化</p></li><li><p>定义一个静态属性对象</p></li><li><p>提供一个静态的公共方法，可以返回对象。如果静态对象为空，则创建对象</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GF</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GF gf;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GF</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GF <span class="title function_">getGF</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(gf == <span class="literal">null</span>)&#123;</span><br><span class="line">gf = <span class="keyword">new</span> <span class="title class_">GF</span>(<span class="string">&quot;萝茵&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gf;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-1-3-两种方法对比"><a href="#4-1-3-两种方法对比" class="headerlink" title="4.1.3 两种方法对比"></a>4.1.3 两种方法对比</h3><ol><li>二者创建对象的时机不同。饿汉式在加载类信息时创建，懒汉式在使用时才创建</li><li>饿汉式可能造成资源浪费，懒汉式可能存在线程安全问题</li><li>Java SE 标准类中 <code>java.lang.Runtime</code> 就是一个单例模式</li></ol><h1 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5 final关键字"></a>5 <code>final</code>关键字</h1><blockquote><p><code>final</code> 可以修饰 类、属性、方法、局部变量</p><p>以下情况下，可能用到 <code>final</code></p><ol><li><code>final</code> 修饰类：该类不能被继承</li><li><code>final</code> 修饰方法：该方法不能被重写</li><li><code>final</code> 修饰值：该值不能被修改</li></ol></blockquote><h2 id="5-1-使用细节"><a href="#5-1-使用细节" class="headerlink" title="5.1 使用细节"></a>5.1 使用细节</h2><ol><li><p><code>final</code> 修饰的属性又叫常量，一般用 XX_XX_XX 来命名（全大写字母+下划线）</p></li><li><p><code>final</code> 修饰的属性在定义时，必须赋初始值，且之后不能再修改。赋值可以在下列位置之一：</p><ul><li>定义时</li><li>构造器中</li><li>代码块中</li></ul><p>注意：如果 <code>final</code> 修饰的属性是静态的，则只能在以下位置赋值。</p><ul><li>定义时</li><li>静态代码块中</li></ul></li><li><p><code>final</code> 类不能继承，但能实例化对象。对的，是可以的。</p></li><li><p>如果不是 <code>final</code> 类，但含有 <code>final</code> 方法，虽然该方法不能重写，但能被继承。</p></li><li><p><code>final</code> 类可以有 <code>final</code> 方法。可以，但没必要。</p></li><li><p><code>final</code> 不能修饰构造方法。</p></li><li><p><code>final</code> 和 <code>static</code> 搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 <code>static</code> 在前）。底层编译器做了优化处理。这样做，调用 <strong>属性（定义时赋值）</strong> 时居然 <strong>不会造成类的加载！</strong></p></li><li><p>包装类（Integer、Double、Float、Boolean、String等）都是 <code>final</code> 类，都不能被继承。</p></li></ol><h1 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6 抽象类"></a>6 抽象类</h1><blockquote><p>当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。那个场合，要将该类声明为 <code>abstract</code> 类。</p><p>抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。</p><p>定义抽象类：<code>访问修饰符 abstract 类名&#123;...&#125;</code></p><p>定义抽象方法（注意：无方法体）：<code>访问修饰符 abstract 返回值 方法名(形参列表);</code></p></blockquote><h2 id="6-1-使用细节"><a href="#6-1-使用细节" class="headerlink" title="6.1 使用细节"></a>6.1 使用细节</h2><ol><li>抽象类不能被实例化</li><li>抽象类不一定包含抽象方法，也就是说，抽象类可以没有<code>abstract</code>方法</li><li>一旦包含 <code>abstract</code> 方法，则该类一定要声明为 <code>abstract</code></li><li><code>abstract</code> 只能修饰 类 和 方法，不能修饰其他。</li><li>抽象类可以有任意成员（非抽象方法、构造器、静态属性等）。即，抽象类本质还是类。</li><li>抽象方法不能有主体。即，抽象方法不能实现。</li><li>如果一个类继承了 <code>abstract</code> 类，则其必须实现所有 <code>abstract</code> 方法，除非其自己也是 <code>abstract</code> 类。</li><li>抽象方法不能用 <code>private</code> <code>final</code> <code>static</code> 来修饰。因为，这些关键词都和 重写 相违背。</li></ol><h1 id="7-接口"><a href="#7-接口" class="headerlink" title="7 接口"></a>7 接口</h1><blockquote><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。</p><p>语法：<code>interface 接口名&#123;...&#125;</code></p><p><code>class 类名 implements 接口名&#123;...必须实现接口的抽象方法...&#125;</code></p><p>注意：JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0 后，接口可以有静态（<code>static</code>）方法、默认（<code>default</code>）方法。</p><p>在接口中，抽象方法可以省略 <code>abstract</code></p></blockquote><p>接口中可以存在：</p><ul><li>属性（只有静态 <code>static</code> 属性，可以不加 <code>static</code> 关键字）</li><li>方法（抽象 <code>abstract</code> 方法、默认 <code>default</code> 实现方法、静态 <code>static</code> 方法）</li></ul><h2 id="7-1-使用细节"><a href="#7-1-使用细节" class="headerlink" title="7.1 使用细节"></a>7.1 使用细节</h2><ol><li>接口 不能被实例化。</li><li>接口中所有方法都是 <code>public</code> 方法。接口中的 抽象方法 可以不用 <code>abstract</code> 修饰。</li><li>一个普通类实现接口，就必须把该接口所有方法都实现。（用快捷键吧 <code>alt + enter</code>）</li><li>抽象类实现接口，可以不用实现接口的方法。</li><li>一个类可以同时实现多个接口。<code>class Name implements In1,In2&#123;...&#125;</code></li><li>接口中的属性只能是 <code>final</code> 的，并且是 <code>public static final</code> 修饰符。修饰符就算不写，还是这样。</li><li>接口中属性的访问形式：<code>接口名.属性名</code></li><li>接口不能 <strong>继承</strong> 其他的类，但可以 <strong>继承</strong> 多个别的接口。（不是也不能 实现 别的接口）</li><li>接口的修饰符只能是 <code>public</code> 和 默认。这点和类的修饰符相同。</li></ol><h2 id="7-2-实现接口-vs-继承类"><a href="#7-2-实现接口-vs-继承类" class="headerlink" title="7.2 实现接口 vs 继承类"></a>7.2 实现接口 vs 继承类</h2><ol><li>当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。</li><li>可以认为，接口 是对于 Java 单继承机制的补充。</li><li>继承的价值主要在于：解决代码的复用性和可维护性。</li><li>接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。</li><li>接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足 like - a 关系。</li><li>接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）</li></ol><h2 id="7-3-接口的多态特性"><a href="#7-3-接口的多态特性" class="headerlink" title="7.3 接口的多态特性"></a>7.3 接口的多态特性</h2><ol><li><p>多态参数（接口的引用可以指向实现了接口的类的对象）</p><blockquote><p><code>viod work(Inerface01 i1)&#123;...&#125;</code> 参数可以传入任意实现该接口的类</p></blockquote></li><li><p>多态数组</p></li><li><p>接口存在多态传递现象</p></li></ol><h1 id="8-内部类"><a href="#8-内部类" class="headerlink" title="8 内部类"></a>8 内部类</h1><blockquote><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;<span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123;<span class="comment">//内部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;<span class="comment">//外部其他类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p></blockquote><h2 id="8-1-四种内部类"><a href="#8-1-四种内部类" class="headerlink" title="8.1 四种内部类"></a>8.1 四种内部类</h2><p>分别是：</p><ul><li>定义在外部类的局部位置上<ul><li>局部内部类：有类名</li><li>匿名内部类：无类名</li></ul></li><li>定义在外部类的成员位置上<ul><li>成员内部类：无<code>static</code>修饰</li><li>静态内部类：<code>static</code>修饰的类</li></ul></li></ul><h2 id="8-2-局部内部类"><a href="#8-2-局部内部类" class="headerlink" title="8.2 局部内部类"></a>8.2 局部内部类</h2><blockquote><p>局部内部类：定义在外部类的局部位置上，并且有类名。（局部位置-比如：方法/代码块里）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tools01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;<span class="comment">//局部内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-1-使用细节"><a href="#8-2-1-使用细节" class="headerlink" title="8.2.1 使用细节"></a>8.2.1 使用细节</h3><ol><li><p>定义在外部类的局部位置上，并且有类名。</p></li><li><p>可以访问外部类的所有成员，包含私有成员</p></li><li><p>局部内部类可以 直接访问 外部类的成员。</p></li><li><p>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></p></li><li><p>作用域 仅仅在定义它的方法或代码块中</p></li><li><p>外部类 在方法中，可以创建 局部内部类 的对象实例，然后调用方法。</p></li><li><p>外部其他类 不能访问 局部内部类</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></p><p><code>外部类名.this</code> 本质就是 外部类的对象。即，调用了该方法（上例的 <code>tools01</code> ）的对象</p><p>还不懂的话，看一下 <a href="https://www.bilibili.com/video/BV1fh411y7R8?p=415&amp;t=289.9">这个视频</a> 悟一悟</p></li></ol><h2 id="8-3-匿名内部类"><a href="#8-3-匿名内部类" class="headerlink" title="8.3 匿名内部类"></a>8.3 匿名内部类</h2><blockquote><p>匿名内部类：定义在外部类的局部位置，且没有类名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口 (参数列表) &#123;</span><br><span class="line">   类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。</p><p>可以用匿名内部类简化开发</p><p>一个例子</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;<span class="comment">//外部类</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tools01</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Inter</span> <span class="variable">whatEver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inter</span>()&#123;<span class="comment">//匿名内部类            </span></span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实，这个匿名内部类 <code>new Inter()&#123;&#125;</code> 的运行类型就是 <code>class XXXX implements Inter</code>。系统自动分配的名字是 <code>Outer$1</code>（<code>whatEver.getClass = &quot;Outer$1&quot;</code>）</p><p>JDK 在创建匿名内部类 <code>Outer$1</code> 时，立即创建了一个对象实例，并将地址返回给了 <code>whatEver</code></p><p>匿名内部类使用一次后就不能再次使用（<code>Outer$1</code> 就这一个了）</p></blockquote><h3 id="8-3-1-使用细节"><a href="#8-3-1-使用细节" class="headerlink" title="8.3.1 使用细节"></a>8.3.1 使用细节</h3><ol><li>匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有 定义类的特征，也有 创建对象的特征。</li><li>可以访问外部类的所有成员，包括私有的。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></li><li>作用域：仅仅在定义它的方法或方法块中</li><li>外部其他类 不能访问 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h3 id="8-3-2-使用场景"><a href="#8-3-2-使用场景" class="headerlink" title="8.3.2 使用场景"></a>8.3.2 使用场景</h3><ol><li>当作实参直接传递，简洁高效</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cellphone</span>().clock(<span class="keyword">new</span> <span class="title class_">Bell</span>() &#123;<span class="comment">//看这里看这里</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">belling</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小懒猪起床了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bell</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ringing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cellphone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clock</span><span class="params">(Bell bell)</span>&#123;</span><br><span class="line">        bell.ringing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-成员内部类"><a href="#8-4-成员内部类" class="headerlink" title="8.4 成员内部类"></a>8.4 成员内部类</h2><blockquote><p>成员内部类：定义在外部类的成员位置，并且没有 <code>static</code> 修饰。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-1-使用细节"><a href="#8-4-1-使用细节" class="headerlink" title="8.4.1 使用细节"></a>8.4.1 使用细节</h3><ol><li>可以直接访问外部类的所有成员，包括私有的</li><li>可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。</li><li>作用域 和外部类其他成员相同，为整个类体。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问成员内部类</li><li>外部其他类访问成员内部类<ul><li><code>Outer.Inner name = Outer.new Inner();</code> 下个方法的缩写</li><li><code>Outer.Inner name = new Outer().new Inner();</code></li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例（就是对象的 getter）</li></ul></li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h2 id="8-5-静态内部类"><a href="#8-5-静态内部类" class="headerlink" title="8.5 静态内部类"></a>8.5 静态内部类</h2><blockquote><p>静态内部类：定义在外部类的成员位置，经由 <code>static</code> 修饰。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-1-使用细节"><a href="#8-5-1-使用细节" class="headerlink" title="8.5.1 使用细节"></a>8.5.1 使用细节</h3><ol><li>可以直接访问外部类的所有 <strong>静态</strong> 成员，包括私有的。但不能访问非静态成员</li><li>可以添加访问修饰符。因为，静态内部类的地位就是一个成员。</li><li>作用域 和其他成员相同，为整个类体。</li><li>静态内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问静态内部类</li><li>外部其他类访问静态内部类<ul><li><code>Outer.Inner name = new Outer.Inner();</code> 即通过类名直接访问</li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.变量名</code>。<em>（怎么不一样了呢？因为静态内部类访问的都是静态成员）</em></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;java&gt;-7 面向对象编程（中级）</title>
      <link href="/2023/02/19/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/"/>
      <url>/2023/02/19/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IDEA的使用"><a href="#1-IDEA的使用" class="headerlink" title="1 IDEA的使用"></a>1 IDEA的使用</h1><blockquote><p>IDE：集成开发环境</p><ul><li>IDEA</li><li>Eeclipse：一个开源的、基于 Java 的可扩展开发平台。是由 IBM 公司开发，在 2001 年 11 月贡献给开源社区的，目前最优秀的 Java 开发 IDE 之一。</li></ul><p>IDEA：全程 IntelliJ IDEA。在业界被公认为最好的 Java 开发工具。是捷克 JetBrains 公司的产品。除了 Java 开发，还支持 HTML，CSS，PHP，MySQL，Python 等。<a href="https://www.jetbrains.com/zh-cn/idea/download/#section=windows">下载地址</a></p></blockquote><h2 id="1-1-常用快捷键"><a href="#1-1-常用快捷键" class="headerlink" title="1.1 常用快捷键"></a>1.1 常用快捷键</h2><ul><li>删除当前行：<code>ctrl + Y</code></li><li>复制当前行：<code>ctrl + D</code></li><li>补全代码：<code>alt + /</code></li><li>添加 / 取消注释：<code>ctrl + /</code></li><li>导入该行需要的类：<code>alt + enter</code></li><li>快速格式化代码：<code>ctrl + alt + L</code></li><li>快速运行程序：<code>shift + F10</code>（我改成了<code>alt + R</code>）</li><li>生成构造器：<code>alt + insert</code></li><li>查看一个类的层级关系：<code>ctrl + H</code></li><li>定位一个方法：把光标放在一个方法上，按 <code>ctrl + B</code></li><li>自动分配变量名：在后面加上 <code>.var</code></li><li>查看模板快捷键：<code>ctrl + J</code></li><li>快速环绕代码：<code>ctrl + alt + T</code></li></ul><h2 id="1-2-模板快捷键"><a href="#1-2-模板快捷键" class="headerlink" title="1.2 模板快捷键"></a>1.2 模板快捷键</h2><ul><li><code>main</code>:<code>public static void main(String[] args) &#123;&#125;</code></li><li><code>sout</code>:<code>System.out.println();</code></li><li><code>fori</code>:<code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></li><li><code>xxx.for</code>:<code>for (int i = 0; i &lt; xxx; i++) &#123;&#125;</code></li></ul><p>更多的请在 File - Settings - Editor - Live template 中查看或添加</p><p>或者，通过下列快捷键查看</p><ul><li><code>ctrl + J</code>：查看模板快捷键</li></ul><h1 id="2-包"><a href="#2-包" class="headerlink" title="2 包"></a>2 包</h1><blockquote><p>包的作用：1.区分相同名字的类 2.当类很多时，便于管理 3.控制访问范围</p><p>语法：<code>package com.name</code> 其中 <code>com</code> <code>name</code> 分别是 一级 和 二级目录，用 <code>.</code> 分隔</p><p>包的本质：就是创建不同 文件夹/目录 来保存 类 文件</p></blockquote><p>如何使用包中的对象：</p><ol><li><p>先引入包，之后创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.name.T;</span><br><span class="line">...</span><br><span class="line"><span class="type">T</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br></pre></td></tr></table></figure></li><li><p>不引入包，而在创建对象时写全路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.name.<span class="type">T</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.name.T();</span><br></pre></td></tr></table></figure></li></ol><p><strong>命名规则：</strong></p><ul><li>只能包含 数字 <code>1 2 3</code>、字母 <code>a b A b</code>、下划线 <code>_</code>、小圆点 <code>.</code></li><li>不能用 数字 开头。每级目录都不能。</li></ul><p><strong>命名规范：</strong></p><ul><li>全小写字母 + 小圆点</li><li><code>com.公司名.项目名.业务模块名</code></li></ul><p><strong>常用的包：</strong></p><p><code>java.lang</code>：基本包，默认引入，不需要再引入</p><p><code>java.util</code>：系统提供的工具包。工具类。</p><p><code>java.net</code>：网络包，网络开发</p><p><code>java.awt</code>：Java 的界面开发，GUI。</p><p><strong>引入包：</strong></p><ul><li>只引入该包下的一个类：<code>import java.util.Scanner</code></li><li>引入该包的所有内容（不建议）：<code>import java.util.*</code></li></ul><p><strong>使用细节：</strong></p><ol><li><p><code>package</code> 的作用是声明当前类所在的包，要放在 类 的 最上面。一个 类 中最多有一句 <code>package</code></p></li><li><p><code>import</code> 放在 <code>package</code> 下面，类定义 前面。可以有多条语句，且没有顺序要求</p></li><li><p>编译器编译时 <strong>不会</strong> 检查目录结构。</p><p>即使一个包处于错误的目录下（只要其不依赖其他包）也可能通过编译。</p><p>但是，虚拟机会找不到该包，最终程序无法运行。</p></li><li><p>从 1.2 版本开始，用户不能再把包放在 java. 开头的目录下了。若如此做，这些包会被禁止加载。</p></li></ol><h2 id="2-1-静态导入"><a href="#2-1-静态导入" class="headerlink" title="2.1 静态导入"></a>2.1 静态导入</h2><blockquote><p>有一种 import 语句允许导入静态方法和字段，而不只是类</p></blockquote><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure><p>这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> pow(<span class="number">10</span>, <span class="number">5</span>);<span class="comment">// &lt;———— 本来是 double n = Math.pow(10, 5);</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> PI;<span class="comment">// &lt;———— 本来是 double pi = Math.PI;</span></span><br></pre></td></tr></table></figure><h1 id="3-访问修饰符"><a href="#3-访问修饰符" class="headerlink" title="3 访问修饰符"></a>3 访问修饰符</h1><h2 id="3-1-访问权限特点"><a href="#3-1-访问权限特点" class="headerlink" title="3.1 访问权限特点"></a>3.1 访问权限特点</h2><p>Java 提供 4 种 访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）</p><ul><li>公开级别：<code>public</code>，对外公开。</li><li>受保护级别：<code>protected</code>，对 子类 和 同一个包中的类 公开。</li><li>默认级别：没有修饰符号，向 同一个包的类 公开。</li><li>私有级别：<code>private</code>，只有 同类 可以访问，不对外公开。</li></ul><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">默认（无修饰符）</th><th style="text-align:center">private</th><th style="text-align:center">protected</th><th style="text-align:center">public</th></tr></thead><tbody><tr><td>本类</td><td style="text-align:center">可</td><td style="text-align:center">可</td><td style="text-align:center">可</td><td style="text-align:center">可</td></tr><tr><td>同包中的子类</td><td style="text-align:center">可</td><td style="text-align:center">不可以</td><td style="text-align:center">可</td><td style="text-align:center">可</td></tr><tr><td>同包的非子类</td><td style="text-align:center">可</td><td style="text-align:center">不可以</td><td style="text-align:center">可</td><td style="text-align:center">可</td></tr><tr><td>其他包的子类</td><td style="text-align:center">不可以</td><td style="text-align:center">不可以</td><td style="text-align:center">可</td><td style="text-align:center">可</td></tr><tr><td>其他包的非子类</td><td style="text-align:center">不可以</td><td style="text-align:center">不可以</td><td style="text-align:center">不可以</td><td style="text-align:center">可</td></tr></tbody></table></div><h2 id="3-2-使用说明"><a href="#3-2-使用说明" class="headerlink" title="3.2 使用说明"></a>3.2 使用说明</h2><ol><li>修饰符可以修饰类中的 属性、成员方法 及 类</li><li>只有 默认 和 <code>public</code> 才能修饰 类，并遵循上述访问权限特点</li><li>成员方法 的访问规则和 属性 相同</li><li>private 修饰的变量可以被 任意本对象同类的对象访问</li></ol><h1 id="4-封装"><a href="#4-封装" class="headerlink" title="4 封装"></a>4 封装</h1><blockquote><p>封装（encapsulation）就是把抽象出的 数据[属性] 和对数据的 操作[方法] 封装在一起。数据 被保护在内部，程序的其他部分只有通过被授权的 操作[方法]，才能对数据进行操作。</p></blockquote><p>封装的好处：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ul><p><strong>实现步骤：</strong></p><ol><li>将属性私有化 <code>private</code></li><li>提供一个公共的 <code>set</code> 方法，用于对属性判断并赋值</li><li>提供一个公共的 <code>get</code> 方法，用于获取属性的值</li></ol><h2 id="4-1-静态导入"><a href="#4-1-静态导入" class="headerlink" title="4.1 静态导入"></a>4.1 静态导入</h2><blockquote><p>有一种 import 语句允许导入静态方法和字段，而不只是类</p></blockquote><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure><p>这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> pow(<span class="number">10</span>, <span class="number">5</span>);<span class="comment">// &lt;———— 本来是 double n = Math.pow(10, 5);</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> PI;<span class="comment">// &lt;———— 本来是 double pi = Math.PI;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-JAR文件"><a href="#4-2-JAR文件" class="headerlink" title="4.2 JAR文件"></a>4.2 JAR文件</h2><blockquote><p>为了避免向用户提供包含大量类文件的复杂目录结构，可以将 Java 程序打包成 JAR （Java 归档）文件。</p><p>一个 JAR 文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。</p><p>JAR 文件是压缩的。其使用了 ZIP压缩格式。</p></blockquote><p><strong>创建 JAR：</strong></p><p>使用 jar 工具以制作 JAR 文件。该工具在 jdk/bin 目录下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvf 包名 文件名<span class="number">1</span> 文件名<span class="number">2</span> ...</span><br></pre></td></tr></table></figure><h1 id="5-继承"><a href="#5-继承" class="headerlink" title="5 继承"></a>5 继承</h1><blockquote><p>继承：能解决代码复用，让我们的编程更接近人类思维。当多个类存在相同的 属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类/超类）。在 父类 中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过 <code>extends</code> 来声明继承父类即可。</p><p>通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;&#125;;<span class="comment">// Son 类继承了 Father 类</span></span><br></pre></td></tr></table></figure><p>定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object 类。</p><p>所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object 本身没有父类。</p><h2 id="5-1-使用细节"><a href="#5-1-使用细节" class="headerlink" title="5.1 使用细节"></a>5.1 使用细节</h2><ol><li>子类 继承了所有属性和方法，但私有（<code>private</code>）的 属性和方法 不能在 子类 直接访问。要调用父类提供的 公共（<code>public</code>）等方法 访问。</li><li>子类 必须调用 父类 的 构造器，完成 父类 的 初始化。</li><li>当创建 子类对象 时，不管使用 子类的哪个构造器，默认情况下总会调用 父类的无参构造器。如果 父类 没有提供 无参构造器，则必须在 子类的构造器 中用 <code>super</code> 去指定使用 父类的哪个构造器 完成 对父类的初始化。否则编译不能通过。</li><li>如果希望指定调用 父类的某构造器，则显式地调用一下：<code>super(形参列表);</code></li><li><code>super</code> 在使用时，必须放在构造器第一行。<code>super</code> 只能在构造器中使用。</li><li>由于 <code>super</code> 与 <code>this</code> 都要求放在第一行，所以此两个方法不能同时存在于同一构造器。</li><li>Java 所有的类都是 <code>Object</code> 的子类。换言之，<code>Object</code> 是所有类的父类。</li><li>父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类 <code>Object</code></li><li>子类 最多只能直接继承 一个 父类。即，Java 中是 单继承机制。</li><li>不能滥用继承。子类 和 父类 之间必须满足 is - a 的逻辑关系。</li></ol><h2 id="5-2-继承的本质"><a href="#5-2-继承的本质" class="headerlink" title="5.2 继承的本质"></a>5.2 继承的本质</h2><ul><li>内存布局：<ol><li>在 方法区，自顶级父类起，依次加载 类信息。</li><li>在堆中开辟一个空间，自顶级父类起，依次创建并初始化各个类包含的所有属性信息</li><li>在栈中存放该空间的地址</li></ol></li><li>如何查找信息？<ol><li>查看该子类是否有该属性，如果该子类有这个属性且可以访问，则返回信息</li><li>子类没有该属性的场合，查看父类是否有该属性。如有且可访问，则返回信息。如不可访问，则报错</li><li>父类也没有该属性的场合，继续查找上级父类，直到顶级父类（Object）</li><li>如需调用某个特定类包含的特定信息，可以调用该类提供的方法</li></ol></li></ul><h2 id="5-3-super关键字"><a href="#5-3-super关键字" class="headerlink" title="5.3 super关键字"></a>5.3 <code>super</code>关键字</h2><blockquote><p><code>super</code> 代表父类的引用。用于访问父类的 属性、方法、构造器</p></blockquote><p><strong>super 的使用：</strong></p><ul><li><code>super.属性名</code>：访问父类的属性。不能访问父类的私有（private）属性。</li><li><code>super.方法名(形参列表)</code>：访问父类的方法。不能访问父类的私有（private）方法。</li><li><code>super(参数列表);</code>：访问父类的构造器。此时，super 语句必须放在第一句。</li></ul><p><strong>使用细节：</strong></p><ol><li>调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。</li><li>子类中有和父类中成员（属性和方法）重名时，要调用父类成员必须用 <code>super</code>。没有重名的场合，<code>super</code>、<code>this</code> 及直接调用的效果相同。</li><li><code>super</code> 的访问不限于直接父类。如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。</li></ol><h2 id="5-4-方法重写-覆盖"><a href="#5-4-方法重写-覆盖" class="headerlink" title="5.4 方法重写/覆盖"></a>5.4 方法重写/覆盖</h2><blockquote><p>方法重写/覆盖（Override）：如若子类有一个方法，和父类的某方法的 名称、返回类型、参数 一样，那么我们就说该子类方法 覆盖 了那个父类方法。</p></blockquote><p><strong>使用细节：</strong></p><ol><li>子类方法的参数，方法名称，要和父类方法完全一致。</li><li>子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。</li><li>子类方法 <strong>不能缩小</strong> 父类方法的访问范围（访问修饰符）。</li></ol><h1 id="6-多态"><a href="#6-多态" class="headerlink" title="6 多态"></a>6 多态</h1><blockquote><p>多态：方法或对象有多种形态。多态是面向对象的第三大特征，是建立在封装和继承的基础之上的</p></blockquote><h2 id="6-1-多态的体现"><a href="#6-1-多态的体现" class="headerlink" title="6.1 多态的体现"></a>6.1 多态的体现</h2><p>方法的多态：重写 和 重载 体现了 方法的多态。</p><p><strong>对象的多态：</strong></p><ul><li><p>一个对象的 编译类型 和 运行类型 可以不一致。</p><p><code>Animal animal = new Dog();</code></p><p>上例，编译类型是 <code>Animal</code>，运行类型是子类 <code>Dog</code>。</p></li><li><p>编译类型在定义对象时就却确定了，不能改变</p></li><li><p>运行类型是可以变化的</p><p>上例中，再让 <code>animal = new Cat();</code>，这样，运行类型变为了 <code>Cat</code></p></li><li><p>编译类型看定义时<code>=</code>的左边，运行类型看<code>=</code>的右边</p></li></ul><h2 id="6-2-使用细节"><a href="#6-2-使用细节" class="headerlink" title="6.2 使用细节"></a>6.2 使用细节</h2><ol><li><p>多态的前提：两个对象 / 类存在继承关系。</p></li><li><p>多态的向上转型：</p><ul><li>本质：父类的引用指向了子类的对象。</li><li>语法：<code>父类类型 引用名 = new 子类类型(参数列表);</code></li><li>编译类型看左边，运行类型看右边。</li><li>可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。</li><li>最终的运行结果要看子类的具体实现。即从子类起向上查找方法调用（与[5.2]规则相同）</li></ul></li><li><p>多态的向下转型：</p><ul><li><p>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></p><p><code>Dog dog = (Dog)animal;</code></p></li><li><p>只能强转父类的引用，不能强转父类的对象。</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象。即上例中的 <code>animal</code> 运行类型需是 <code>Dog</code></p></li><li><p>向下转型后，可以调用子类类型中的所有成员。</p></li></ul></li><li><p>属性没有重写一说。<strong>和 方法 不同，属性的值 看编译类型。</strong></p></li><li><p><code>instanceof</code> 比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是 <strong>运行类型</strong>。</p></li></ol><h2 id="6-3-理解方法调用"><a href="#6-3-理解方法调用" class="headerlink" title="6.3 理解方法调用"></a>6.3 理解方法调用</h2><p>在对象上调用方法的过程如下：</p><ol><li><p>编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举</p><p>至此，编译器已经知道所有可能被调用的方法</p></li><li><p>编译器确认方法调用中提供的参数类型。</p><p>那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。</p><p>没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错</p><p>至此，编译器已经知道要嗲用方法的名字和参数类型</p></li><li><p>如若是private方法、static方法、final方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为<strong>静态绑定</strong></p><p>与之相对的，如果调用方法依赖于隐式参数类型，那么必须在运行时<strong>动态绑定</strong></p></li><li><p>程序运行并采取动态绑定方法时，JVM将调用那个<strong>实际类型</strong>对应的方法</p></li></ol><p>倘若每次调用发发都进行以上搜索，会造成庞大的时间开销。为此，JVM预先为每个类计算了<strong>方法表</strong></p><p>方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可</p><p>特别的，使用super关键字时，JVM会查找其父类的方法表</p><p><strong><font color=red>动态绑定机制：</font></strong></p><ul><li>当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址/运行类型绑定</li><li>当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用</li></ul><h1 id="7-Object类"><a href="#7-Object类" class="headerlink" title="7 Object类"></a>7 Object类</h1><blockquote><p>Object 类是所有类的超类。Java 中所有类默认继承该类。</p></blockquote><h2 id="7-1-equals方法"><a href="#7-1-equals方法" class="headerlink" title="7.1 equals方法"></a>7.1 equals方法</h2><p><code>boolean equals(Object obj)</code></p><p>用于检测一个对象是否等于另一对象。</p><p>在 Object 中，该方法的实现是比较 形参 与 隐式参数 的对象引用是否一致。</p><p><strong>与 <code>==</code> 的区别：</strong></p><ul><li><p><code>==</code>：既可以判断基本类型，也可以判断引用类型。如果判断基本类型，判断的是值是否相等。如果判断引用类型，判断的是地址是否相等。</p></li><li><p>equals 方法：是 Object 中的方法，只能判断引用类型。默认判断地址是否相等，但子类中往往重写该代码，以判断内容是否相等。</p><p>在子类中定义 equals 方法时，首先调用超类的 equals 方法。两个一致时，再比较子类中的字段。</p></li></ul><p><strong>Java 语言规范要求 equals 方法具有如下特性：</strong></p><ul><li><p><em>自反性</em>：对于任何非空引用 x，<code>x.equals(x)</code> 应返回 true</p></li><li><p><em>对称性</em>：对于任何引用 x 和 y，当且仅当 <code>x.equals(y)</code> 为 true 时，<code>y.equals(x)</code> 为 true</p><p>如果所有的子类具有相同的相等性语义，可以使用 <code>instanceof</code> 检测其类型。否则，最好使用 <code>getClass</code> 方法比较类型。</p></li><li><p><em>传递性</em>：对于任何引用 x、y、z，如果 <code>x.equals(y)</code> 为 true ，<code>y.equals(z)</code> 为 true，那么 <code>x.equals(z)</code> 也应该为 true</p></li><li><p><em>一致性</em>：如果 x 和 y 的引用没有发生变化，反复调用 <code>x.equals(y)</code> 应该返回相同的结果</p></li><li><p>对于任何非空引用 x，<code>x.equals(null)</code> 应该返回 false</p></li></ul><h2 id="7-2-hashCode方法"><a href="#7-2-hashCode方法" class="headerlink" title="7.2 hashCode方法"></a>7.2 hashCode方法</h2><p><code>int hashCode()</code></p><p>返回对象的 散列码值。</p><p>散列码值是由对象导出的一个整型值。散列码是无规律的。如果 x 与 y 是不同对象，两者的散列码基本上不会相同。</p><p>字符串的散列码是由其内容导出的，而其他引用对象的散列码是根据存储地址得出的。</p><p><strong>散列码的作用：</strong></p><ol><li>提高哈希结构的容器的效率。</li><li>两个引用，若是指向同一对象，则哈希值一般不同。</li><li>哈希值是根据地址生成的，因而，哈希值不能等同于地址</li></ol><p><strong>相关方法：</strong></p><ul><li><p><code>Objects.hashCode(Object obj)</code></p><p>这是一个 null 安全的返回散列值的方法。传入 null 时会返回 0</p></li><li><p><code>Objects.hash(Object... values)</code></p><p>组合所有传入参数的散列值</p></li><li><p><code>Integer.hashCode(int value)</code></p><p>返回给定基本数据类型的散列值。所有包装类都有该静态方法</p></li><li><p><code>Arrays.hashCode(xxx[] a)</code></p><p>计算数组的散列码。数组类型可以是 Object 或基本数据类型</p></li></ul><p>空对象调用 hashCode 方法会抛出异常。</p><p>hashCode 与 equals 的定义必须相符。如果 <code>x.equals(y)</code> 返回 true，那么 <code>x.hashCode()</code> 与 <code>y.hashCode()</code> 应该返回相同的值。</p><h2 id="7-3-toString方法"><a href="#7-3-toString方法" class="headerlink" title="7.3 toString方法"></a>7.3 toString方法</h2><p><code>String toString()</code></p><p>返回表示对象的一个字符串。Object 的默认实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Class getClass()</code></p><p>返回包含对象信息的 Class 对象。</p></li><li><p><code>String getName()</code></p><p>由 Class 类实例调用。返回这个类的全类名</p><p>全类名：即包名 + 类名。比如 <code>com.prictice.codes.Person</code></p></li><li><p><code>Class getSuperClass()</code></p><p>由 Class 类实例调用。以 Class 形式返回其父类</p><p>Object 使用时返回 null</p></li><li><p><code>Integer.toHexString(int val)</code></p><p>返回一个数字的十六进制表示的字符串</p></li></ul><p>toString 方法非常实用。Java 标准类库中的很多类重写了该方法，以便用户能获得一些有关对象状态的信息。</p><p>打印对象 或 使用 <strong>+</strong> 操作符拼接对象 时，都会自动调用该对象的 toString 方法。</p><p>当直接调用对象时，也会默认调用该方法。</p><h2 id="7-4-finalize方法"><a href="#7-4-finalize方法" class="headerlink" title="7.4 finalize方法"></a>7.4 finalize方法</h2><ol><li>当对象被回收时，系统会自动调用该对象的 <code>finalize</code> 方法。子类可以重写该方法，做一些释放资源的操作。</li><li>何时被回收：当某对象没有任何引用时，JVM 就认为该对象是一个垃圾对象，就会（在算法决定的某个时刻）使用垃圾回收机制来销毁该对象。在销毁该对象前，会调用 <code>finalize</code> 方法。</li><li>垃圾回收机制的调用，是由系统决定。也可以通过 <code>System.gc();</code> 主动触发垃圾回收机制。这个方法一经调用就会继续执行余下代码，而不会等待回收完毕。</li><li>实际开发中，几乎不会运用该方法。</li></ol><h1 id="8-断点调试（Debug）"><a href="#8-断点调试（Debug）" class="headerlink" title="8 断点调试（Debug）"></a>8 断点调试（Debug）</h1><blockquote><p>断点调试：在程序某一行设置一个断点，调试时，代码运行至此就会停住，然后可以一步一步往下调试。调试过程中可以看各个变量当前的值。如若出错，则测试到该出错代码行即显示错误并停下。进行分析从而找到这个 Bug。</p><p>调试过程中是运行状态，所以，是以对象的 运行类型 执行。</p><p>断点调试是程序员必须掌握的技能，能帮助我们查看 Java 底层源代码的执行过程，提高程序员 Java 水平。</p></blockquote><p>快捷键如下</p><ul><li>跳入：<code>F7</code></li><li>跳过：<code>F8</code></li><li>跳出：<code>shift + F8</code></li><li>resume，执行到下一个断点：<code>F9</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JRebel热部署</title>
      <link href="/2023/02/01/JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/02/01/JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="JRebel插件实现热部署"><a href="#JRebel插件实现热部署" class="headerlink" title="JRebel插件实现热部署"></a>JRebel插件实现热部署</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>JRebel是一套JavaEE开发工具。可快速实现热部署，节省了大量重启时间，提高了个人开发效率。</p><p>JRebel是一款JAVA虚拟机插件，它使得JAVA程序员能在不进行重部署的情况下，即时看到代码的改变对一个应用程序带来的影响。他使你能即时分别看到代码、类和资源的变化，你可以一个个地上传而不是一次性全部部署。当程序员在开发环境中对任何一个类或者资源作出修改的时候，这个变化会直接反应在部署好的应用程序上，从而跳过了构建和部署的过程，可以省去大量的部署用的时间。</p><p>JRebel是一款JVM插件，它使得Java代码修改后不用重启系统，立即生效。</p><p>IDEA上原生是不支持热部署的，一般更新了 Java 文件后要手动重启 Tomcat 服务器，才能生效，浪费时间浪费生命。<br>目前对于idea热部署最好的解决方案就是安装JRebel插件。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="（一）安装插件"><a href="#（一）安装插件" class="headerlink" title="（一）安装插件"></a>（一）安装插件</h3><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/IDEA/image-20230201103356096.png" alt="插件市场"></p><h3 id="（二）在线GUID地址"><a href="#（二）在线GUID地址" class="headerlink" title="（二）在线GUID地址"></a>（二）在线GUID地址</h3><p>网址：<a href="https://www.guidgen.com/">在线GUID地址</a></p><p>服务器地址：<a href="http://idea.javatiku.cn/`{GUID}`">http://idea.javatiku.cn/`{GUID}`</a></p><h3 id="（三）激活JRebel"><a href="#（三）激活JRebel" class="headerlink" title="（三）激活JRebel"></a>（三）激活JRebel</h3><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/IDEA/image-20230201103646406.png" alt="激活"></p><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/IDEA/image-20230201103807476.png" alt="服务器路径"></p><p>安装成功之后就可以通过JRebel启动项目。这样修改完Java代码后，就可以通过快捷键 <strong>Ctrl+shift+F9</strong> 而不再需要重启站点这样繁琐浪费时间的操作了。</p><h3 id="（三）使用"><a href="#（三）使用" class="headerlink" title="（三）使用"></a>（三）使用</h3><p>在IDEA右侧将自动编译打开之后，修改代码即可自动重新编译啦</p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JRebel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-6 面向对象编程（基础）</title>
      <link href="/2023/01/30/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
      <url>/2023/01/30/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程（基础）"><a href="#面向对象编程（基础）" class="headerlink" title="面向对象编程（基础）"></a>面向对象编程（基础）</h1><blockquote><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。</p></blockquote><h2 id="1-类与对象（OOP）"><a href="#1-类与对象（OOP）" class="headerlink" title="1 类与对象（OOP）"></a>1 类与对象（OOP）</h2><blockquote><p>类:就是数据类型。可以是 <code>int</code> 也可以是 <code>人类</code></p><p>对象:就是其中具体的实例。可以是 <code>100</code> 也可以是 <code>韩顺平</code></p><p>从 类 到 对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者 把对象实例化</p><ol><li>类 是抽象的、概念的，代表一类事物</li><li>对象 是具体的、实际的，代表一个个具体事物</li><li>类 是 对象 的模板，对象 是 类 的一个个体，对应一个实例</li></ol></blockquote><p>下面，我们定义了一个类 <code>Cat</code> 并创建了一些 对象 <code>cat1</code> <code>cat2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code6_1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat1.name = <span class="string">&quot;福福&quot;</span>;</span><br><span class="line">        cat1.age = <span class="number">2</span>;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat2.name = <span class="string">&quot;妞子&quot;</span>;</span><br><span class="line">        cat2.age = <span class="number">1</span>;</span><br><span class="line">        System.out.println(cat1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-属性-成员变量"><a href="#1-1-属性-成员变量" class="headerlink" title="1.1 属性/成员变量"></a>1.1 属性/成员变量</h3><blockquote><p>从概念或叫法上看：成员变量 = 属性 = field（字段）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>String name;</code> 就是一个成员变量（属性）。</p><p>属性可以是基本数据类型，也可以是引用数据类型。</p><ol><li>属性的定义语法同变量。<code>访问修饰符 属性类型 属性名</code><ul><li>访问修饰符：控制属性的访问范围。有四种：<code>publie</code> <code>protected</code> <code>默认(空)</code> <code>private</code></li></ul></li><li>属性的定义类型可以为任意类型，包含 基本类型 或 引用类型</li><li>属性如果不赋值，有默认值。</li></ol><h3 id="1-2-创建对象"><a href="#1-2-创建对象" class="headerlink" title="1.2 创建对象"></a>1.2 创建对象</h3><ul><li><p>先声明再创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat1;      <span class="comment">//声明对象cat1</span></span><br><span class="line">cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure></li><li><p>直接创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ol><li>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。对象的引用，也被称为对象的句柄。</li><li>使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用。</li></ol><h3 id="1-3-访问对象"><a href="#1-3-访问对象" class="headerlink" title="1.3 访问对象"></a>1.3 访问对象</h3><p>基本语法：<code>对象名.属性名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cat1.name);</span><br></pre></td></tr></table></figure><h3 id="1-4-类与对象的内存访问机制"><a href="#1-4-类与对象的内存访问机制" class="headerlink" title="1.4 类与对象的内存访问机制"></a>1.4 类与对象的内存访问机制</h3><blockquote><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如<code>Cat cat1 = new Cat()</code>，是在这里开辟的空间）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><ol><li>创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈 中的对象名被赋予指向那个空间的地址。</li><li>之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在 堆 中；是 字符串 的记录一个地址，该地址指向 方法区，那里的常量池有该字符串。</li></ol><h2 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2 成员方法"></a>2 成员方法</h2><p>在某些情况下，我们需要定义成员方法。比如 <code>Cat</code> 除了有属性（<code>name</code> <code>age</code>）外，还可以有一些行为比如玩耍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回数据类型 方法名(形参列表)&#123;</span><br><span class="line">方法体语句;</span><br><span class="line">returen 返回值;<span class="comment">//返回数据类型是 void 的场合，return语句不是必须的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>方法名必须是一个合法的标识符</p></li><li><p>返回类型即返回值的类型。如果方法没有返回值，应声明为 void</p></li><li><p>修饰符段可以有几个不同的修饰符。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;哎咿呀~ 哎咿呀~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 public（访问修饰符）、static（static 关键字）、final（final 关键字）</p></li><li><p>参数列表是传递给方法的参数表。各个元素间以 <code>,</code> 分隔。每个元素由一个类型和一个标识符表示的参数组成。</p><p>特别地，<code>参数类型... 标识符</code> 这样的参数被称为可变参数</p></li><li><p>方法体是实际要执行的代码块。方法体一般用 return 作为方法的结束。</p></li></ol><p>使用 成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    String name;<span class="comment">//属性 name</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//属性 age</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;<span class="comment">//方法 speak()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;喵~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法写好后，不去调用就不会输出</li><li>先创建对象，然后调用方法即可</li></ol></blockquote><p>下面，展示一个含有成员方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code6_2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">       cat1.speak(<span class="number">10</span>, <span class="number">15</span>);<span class="comment">//调用 speak 方法，并且给 n1 = 10, n2 = 15</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> cat1.speak2(<span class="number">15</span>, <span class="number">135</span>);<span class="comment">//调用 speak2 方法,返回值赋给 r</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;<span class="comment">//(int n1, int n2)形参列表，当前有两个形参 n1,n2</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">       System.out.println(<span class="string">&quot;喵~&quot;</span> + n1 + <span class="string">&quot; + &quot;</span> + n2 +<span class="string">&quot; 的值是：&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">speak2</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;<span class="comment">//int 表示方法执行后，返回一个 int 值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">       <span class="keyword">return</span> res;<span class="comment">//返回 res 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-方法的调用机制"><a href="#2-1-方法的调用机制" class="headerlink" title="2.1 方法的调用机制"></a>2.1 方法的调用机制</h3><p>以前文代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> cat1.speak2(<span class="number">15</span>, <span class="number">135</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">speak2</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>当程序执行到方法时，在栈里开辟一个新的栈空间。该空间里存储<code>n1 = 15</code> <code>n2 = 135</code>，之后计算并存储结果<code>res = 150</code></li><li>当方法执行完毕，或执行到return语句时，就会返回</li><li>把新栈空间中的<code>res = 150</code>返回 main栈 中调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li></ol><h3 id="2-2-使用细节"><a href="#2-2-使用细节" class="headerlink" title="2.2 使用细节"></a>2.2 使用细节</h3><ol><li><p>访问修饰符：作用是控制方法的使用范围。</p><ul><li>不写（默认访问控制范围）</li><li>public：公共</li><li>protected：受保护</li><li>private：私有</li></ul></li><li><p>返回数据类型：</p><ul><li>一个方法最多有一个返回值。要返回多个结果可以使用 数组。</li><li>返回类型为任意类型。包括 基本数据类型 和 引用数据类型。</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必为 <code>return 值</code>，且返回类型必须和 return 的值一致。</li><li>如果 返回数据类型 为 <code>void</code>，则可以不写 <code>return</code> 语句</li></ul></li><li><p>方法名：</p><ul><li>遵循驼峰命名法，最好见名知意，表达出该功能的意思。</li></ul></li><li><p>参数列表（形参列表）：</p><ul><li>一个方法可以有 0 个参数，也可以有多个参数。参数间用 <code>,</code> 间隔。</li><li>参数类型可以为任意类型，包含 基本类型 和 引用类型。</li><li>调用带参数的方法时，一定对应着 参数列表 传入 相同类型 或 兼容类型 的参数。</li><li>方法定义时的参数称为 形式参数 ，简称 形参；方法调用时的参数（传入的参数）称为 实际参数，简称 实参。实参 与 形参 的类型、个数、顺序必须一致。</li></ul></li><li><p>方法体：</p><ul><li>写完成功能的具体语句。方法中不能再定义方法。即：方法不能嵌套定义。</li></ul></li><li><p>调用细节：</p><ul><li>同一个类中的方法调用，可以直接调用。</li><li>跨类的方法调用，需要创建新对象，然后再调用方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">      m1();<span class="comment">//同一个类中的方法调用，可以直接调用。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">C1</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C1</span>();</span><br><span class="line">      c.m2();<span class="comment">//跨类的方法调用，需要创建新对象，然后再调用方法。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-成员方法传参机制"><a href="#2-3-成员方法传参机制" class="headerlink" title="2.3 成员方法传参机制"></a>2.3 成员方法传参机制</h3><p>Java 语言对对象采用的是 <strong>值传递</strong>，方法得到的总是那个传入对象的副本。</p><ul><li><p>方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参。</p></li><li><p>方法可以改变对象参数的状态。</p><p>引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>但改变那个形参地址指向的场合，实参的指向不会改变。</p></li></ul><h2 id="3-方法递归调用"><a href="#3-方法递归调用" class="headerlink" title="3 方法递归调用"></a>3 方法递归调用</h2><blockquote><p>递归：即方法自己调用自己，每次调用时传入不同变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p></blockquote><p>下面，示范一个斐波那契数列方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (fib(n - <span class="number">1</span>)) + (feb(n - <span class="number">2</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-使用细节"><a href="#3-1-使用细节" class="headerlink" title="3.1 使用细节"></a>3.1 使用细节</h3><ol><li>执行一个方法时，就创建一个新的受保护的独立 栈空间。</li><li>方法的局部变量是独立的，不会相互影响。</li><li>如果方法中使用的是引用变量，就会共享数据。</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示 <code>StackOverflowError</code> “死龟”</li><li>当一个方法执行完毕，或遇到 <code>return</code> 就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕。</li></ol><h2 id="4-方法重载"><a href="#4-方法重载" class="headerlink" title="4 方法重载"></a>4 方法重载</h2><blockquote><p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求 形参列表 不一致。</p><p>这样，减轻了起名和记名的麻烦。</p></blockquote><p><strong>使用细节：</strong></p><ol><li>方法名：必须相同</li><li>形参列表：必须不同（参数的类型、个数、顺序，这其中至少一个不同）</li><li>返回值：无要求</li></ol><p><strong>签名：</strong></p><p>由于重载的存在，要完整的描述一个方法，要指定方法名及参数类型。这叫做方法的签名。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">act</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法的签名分别是：<code>act()</code> 和 <code>act(int n)</code></p><h2 id="5-可变参数"><a href="#5-可变参数" class="headerlink" title="5 可变参数"></a>5 可变参数</h2><blockquote><p>Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(<span class="type">int</span>... n)</span>&#123;</span><br><span class="line"><span class="comment">//此时，n 相当于一个 数组。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> n.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> n[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-使用细节"><a href="#5-1-使用细节" class="headerlink" title="5.1 使用细节"></a>5.1 使用细节</h3><ol><li><p>可变参数 的实参可以是 0 个，也可以是 任意多 个。</p></li><li><p>可变参数 的实参可以是数组</p></li><li><p>可变参数 本质就是数组</p><p>因此，出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">met</span><span class="params">(<span class="type">int</span>... n)</span>&#123;<span class="comment">//这个方法与下面的方法不能构成重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的场合，不能有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">met</span><span class="params">(<span class="type">int</span>[] n)</span>&#123;<span class="comment">//这个方法与上面的方法不能构成重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数 在最后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(<span class="type">double</span> dou, <span class="type">int</span>... n)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个形参列表最多出现 一个 可变参数。</p></li></ol><h2 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6 作用域"></a>6 作用域</h2><ol><li>在 Java 编程中，主要的变量就是 属性（成员变量）和 局部变量</li><li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是 属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。局部变量必须赋值使用</li></ol><h3 id="6-1-使用细节"><a href="#6-1-使用细节" class="headerlink" title="6.1 使用细节"></a>6.1 使用细节</h3><ol><li><p>属性 和 局部变量 可以重名，访问时遵循就近原则</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>属性 的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。</p><p>局部变量 生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。</p></li><li><p>全局变量/属性 可以被本类使用，也可以被其他类（通过对象）使用。</p><p>局部变量 只能被本类的对应方法中调用</p></li><li><p>全局变量/属性 <strong>可以加</strong> 修饰符</p><p>局部变量 <strong>不能加</strong> 修饰符</p></li></ol><h2 id="7-构造方法、构造器"><a href="#7-构造方法、构造器" class="headerlink" title="7 构造方法、构造器"></a>7 构造方法、构造器</h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。</p></blockquote><p>语法：<code>[修饰符] 方法名(形参列表)&#123;方法体&#125;</code></p><ol><li>构造器的修饰符可以是默认。也可以是别的</li><li>参数列表 规则同 成员方法</li></ol><p>以下示范一个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> mun;</span><br><span class="line">    <span class="comment">//下面这块就是构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String str, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">name = str;</span><br><span class="line">num = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-1-使用细节"><a href="#7-1-使用细节" class="headerlink" title="7.1 使用细节"></a>7.1 使用细节</h3><ol><li>构造器本质也是方法，所以可以构造器重载</li><li>构造器名和类名相同</li><li>构造器无返回值</li><li>构造器是完成对象的初始化，而不是创建</li><li>创建对象时，系统自动调用构造器</li><li>如果程序员没有定义构造器，系统会自动给类生成一个无参构造器（默认构造器）</li><li>一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器</li></ol><h3 id="7-2-流程分析"><a href="#7-2-流程分析" class="headerlink" title="7.2 流程分析"></a>7.2 流程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Amy&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span>&#123;</span><br><span class="line">name = pName;</span><br><span class="line">age = pAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>加载类信息（方法区）</p></li><li><p>在堆中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化<code>age = 0; name = null</code></p></li><li><p>之后显示初始化<code>age = 20; name = null</code></p><p>其中，显示初始化和代码块初始化按编写的先后顺序依次进行。</p></li><li><p>之后构造器的初始化<code>age = 10, name = &quot;Amy&quot;</code></p></li></ul></li><li><p>把对象在堆中的地址返回给p1</p></li></ol><h2 id="8-this关键字"><a href="#8-this关键字" class="headerlink" title="8 this关键字"></a>8 this关键字</h2><blockquote><p>JVM会给每个对象分配this代表当前对象</p><p>相当于在堆中this指向自己（对象）</p><p>在类定义的方法中，Java会自动用this关键字把所有变量和方法引用结合在一起</p><p>遇到有同名的局部变量的场合，需要程序员加入this关键字进行区分。不加入this关键字的场合，java遵循就近原则</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">(<span class="type">int</span> n)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个类的<code>act()</code>方法实际有2个参数。对其调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Example</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exmaple</span>();</span><br><span class="line">e.act(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>可见，出现在方法名前的参数<code>e</code>，以及出现在方法名后的括号中的参数<code>100</code>，出现在方法名前的参数被称为<strong>隐式参数</strong>（也称为方法调用的目标或接收者），出现在方法名后的参数被称为<strong>显示参数</strong>，就是所谓的实参。</p><p>在每一个方法中，用this指代隐式参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，再以相同方式调用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.act(<span class="number">100</span>);<span class="comment">// &lt;———— 相当于 e.n = 100;</span></span><br></pre></td></tr></table></figure><h3 id="8-1-使用方法"><a href="#8-1-使用方法" class="headerlink" title="8.1 使用方法"></a>8.1 使用方法</h3><ol><li><code>this</code> 关键字可以用来访问本类的属性、方法、构造器</li><li><code>this</code> 用于区分当前类的 属性 和 局部变量</li><li>访问本类中成员方法的语法：<code>this.方法名</code></li><li>访问构造器的语法：<code>this(参数列表);</code></li><li>注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。</li><li><code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中 使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-5 数组与排序</title>
      <link href="/2023/01/30/Java-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/01/30/Java-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="数组、排序和查找"><a href="#数组、排序和查找" class="headerlink" title="数组、排序和查找"></a>数组、排序和查找</h1><blockquote><p>数组：可以存放多个同一类型的数据。数组也是一种数据，是引用类型，即数组就是一组数据。</p></blockquote><h2 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1 一维数组"></a>1 一维数组</h2><blockquote><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。</p><p>数组中的元素可以是任何数据类型。包括基本类型和引用类型。</p><p>数组的下标从 0 开始。且必须在指定范围内使用，否则报错。</p><p>数组属于 引用类型，数组型数据是 对象（Object）</p><p>数组创建后，如果没有赋值，有默认值：int（0），short（0），byte（0），long（0L），float（0.0F），double（0.0），char（000），boolean（false），String（null），Object（null）</p></blockquote><p><strong>数组的构造方法：</strong></p><p>使用数组的步骤：1.声明数组并开辟空间 2.给数组各个元素赋值 3.使用数组</p><ul><li><p>构造方式1：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];<span class="comment">// 创建了数组 name，存放5个int</span></span><br><span class="line"><span class="type">int</span> ints2[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];<span class="comment">// 这种写法也行</span></span><br><span class="line">ints[<span class="number">2</span>] = <span class="number">15</span>;<span class="comment">// 访问数组第3个数</span></span><br></pre></td></tr></table></figure></li><li><p>构造方式2：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chars;<span class="comment">// 先声明数组 name，此时数组是 null</span></span><br><span class="line">chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];<span class="comment">// 分配内存空间，可以存放数据了</span></span><br><span class="line">chars[<span class="number">1</span>] = <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>构造方式3：静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] bools = &#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;阿伟，你又在打电动噢&quot;</span>, <span class="string">&quot;烦啦&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>确切知道数组每个元素的场合可以用这个方法。</p></li></ul><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：<code>数组名[元素下标]</code></p><p>其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素 <code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h3 id="1-1-数组赋值机制"><a href="#1-1-数组赋值机制" class="headerlink" title="1.1 数组赋值机制"></a>1.1 数组赋值机制</h3><ol><li><p>基本数据类型赋值，赋值方式是值拷贝。这个值就是具体的数据，且互不影响</p></li><li><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array2 = array1;</span><br><span class="line">array2[<span class="number">0</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>上述情况下，<code>array1[0]</code> 也会变成 <code>100</code>。因为数组在 JVM 的 栈 里是一个地址，指向 堆 里的一个空间。这两个数组在上述情况下指向同一空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array1.length;i++) &#123;</span><br><span class="line">    array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方式拷贝后，两数组相互独立。</p></li></ol><h3 id="1-2-数组的扩容"><a href="#1-2-数组的扩容" class="headerlink" title="1.2 数组的扩容"></a>1.2 数组的扩容</h3><p>当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><p>以下是一个扩容方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code5_1_3</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">inP</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">// 这是原数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 这个变量记录输入的新元素的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> arr1.length;<span class="comment">// 这个变量是新数组的长度</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">yN</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">// 记录询问继续与否时用户的输入字符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">/* 创建多一位的新数组，把新元素赋给新数组的最后一位 */</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入添加数字：&quot;</span>);</span><br><span class="line">            add = inP.nextInt();</span><br><span class="line">            <span class="type">int</span>[] tem = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + <span class="number">1</span>];</span><br><span class="line">            tem[count] = add;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 把旧数组的值全部赋给新数组 */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">                tem[i] = arr1[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 把新数组保存下来，输出现在的数组 */</span></span><br><span class="line">            arr1 = tem;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n\n当前数组为：&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">                System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 询问是否继续添加，输入n跳出，否则循环 */</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\n\n是否继续添加？（Y/N）&quot;</span>);</span><br><span class="line">            yN = inP.next().charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">while</span>(yN != <span class="string">&#x27;N&#x27;</span> &amp;&amp; yN != <span class="string">&#x27;n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2 二维数组"></a>2 二维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] ints;<span class="comment">// 声明一个二维数组</span></span><br><span class="line"><span class="type">int</span>[] ints2[];<span class="comment">// 也能这样声明</span></span><br><span class="line"><span class="type">int</span> ints3[][];<span class="comment">// 这样也行</span></span><br><span class="line"><span class="type">int</span>[] x,y[];<span class="comment">// 声明了两个数组，一个是 int[] x 一个是 int[][] y</span></span><br><span class="line"><span class="comment">// 把 int[] 视作一个类型，就能很好地理解这个写法</span></span><br></pre></td></tr></table></figure><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。</p><p>数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><p><strong>二维数组构造方法：</strong></p><ul><li><p>构造方法1：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] many_ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]<span class="comment">// 创建 有3个 包含4个元素的一维数组 的二维数组</span></span><br></pre></td></tr></table></figure></li><li><p>构造方法2：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[][] many_doubles;<span class="comment">// 先声明变量</span></span><br><span class="line">many_doubles = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">// 再开辟空间</span></span><br></pre></td></tr></table></figure></li><li><p>构造方法3：动态初始化-列数不确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[][] many_chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>][];<span class="comment">// 创建一个三行列数不确定的二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    many_chars[i] = <span class="keyword">new</span> <span class="title class_">char</span>[i + <span class="number">1</span>];<span class="comment">// 此时，每个数组空间依次增大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法4：静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] many_many = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">10</span>, <span class="number">2</span>&#125;, &#123;<span class="number">95</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>二维数组使用方法：</strong></p><ul><li><code>ints.length</code>：该二维数组的长度，这里是 3</li><li><code>ints[0]</code>：该二维数组的第一个子数组</li><li><code>ints[0].length</code>：该二维数组的第一个子数组的长度，这里是 4</li><li><code>ints[1][0]</code>：该二维数组第二个子数组的第一个元素的值，这里是 21</li></ul><h2 id="3-查找算法"><a href="#3-查找算法" class="headerlink" title="3 查找算法"></a>3 查找算法</h2><p>在 Java 中，常用的查找有 4 种：</p><ul><li>顺序查找（遍历）</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li></ul><h3 id="3-1-线性查找"><a href="#3-1-线性查找" class="headerlink" title="3.1 线性查找"></a>3.1 线性查找</h3><p>逐一比对，直到发现目标值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">seqSearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-二分查找"><a href="#3-2-二分查找" class="headerlink" title="3.2 二分查找"></a>3.2 二分查找</h3><p>二分查找要求数组必须是有序数组。</p><p>每次取出那个中位数。目标值大于中位数的场合，则在较小一侧的范围内继续二分查找。否则在那个较大一侧查找。</p><p>递归方式二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(array, target, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> -l - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target == array[p]) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[p]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(array, target, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> binarySearch(array, target, l, p - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方式二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; l) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == array[p]) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[p]) l = p + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -l - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-插值查找"><a href="#3-3-插值查找" class="headerlink" title="3.3 插值查找"></a>3.3 插值查找</h3><p>插值查找类似于二分查找，但其不是取出中位数，而是从自适应的位置取出一个元素</p><p>那个自适应的取出位置 mid = low + (target - arr[low]) × (high - low) / (arr[high] - arr[low])</p><p>如若那个目标值更靠近某一端，这个自适应的取出位置也会更接近那一端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertSearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; array[array.length - <span class="number">1</span>]) <span class="keyword">return</span> -array.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l) &#123;</span><br><span class="line">        p = l + (target - array[l]) * (r - <span class="number">1</span> - l) / (array[r - <span class="number">1</span>] - array[l]);</span><br><span class="line">        <span class="keyword">if</span> (target == array[p]) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[p]) l = p + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-斐波那契查找"><a href="#3-4-斐波那契查找" class="headerlink" title="3.4 斐波那契查找"></a>3.4 斐波那契查找</h3><p>斐波那契查找原理与前两种类似，仅仅改变了中间节点的位置。</p><p>其中间节点不是中位或插值，而是位于黄金分割点附近。</p><h2 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="4 排序算法"></a>4 排序算法</h2><blockquote><p>排序也叫排序算法。是将一组数据，依指定的顺序进行排列的过程</p></blockquote><p>排序分为两类：</p><ul><li><p>内部排序：将所有要处理的数据加载到内部存储器中进行排序</p><p>内部排序主要有以下几种：</p><ul><li>插入排序：直接插入排序、希儿排序</li><li>选择排序：简单选择排序、堆排序</li><li>交换排序：冒泡排序、快速排序</li><li>归并排序</li><li>基数排序</li></ul></li><li><p>外部排序：数据量庞大，无法全部加载到内存中，需要借助外部存储进行排序</p><p>如：合并排序法、直接合并排序法</p></li></ul><p><strong>排序算法的时间复杂度：</strong></p><div class="table-container"><table><thead><tr><th>排序法</th><th>平均时间</th><th>最差情形</th><th>稳定性</th><th>额外空间</th><th>说明</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><td>交换排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><td>选择排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><td>插入排序</td><td>O($n^2$)</td><td>O($n^2$)</td><td>稳定</td><td>O(1)</td><td>大部分已排序时较好</td></tr><tr><td>基数排序</td><td>O(n × k)</td><td>O(n × k)</td><td>稳定</td><td>O(n)</td><td>k 是 “桶” 的个数</td></tr><tr><td>Shell 排序</td><td>O($n(log_{2}n)$)</td><td>O($n(log_{2}n)^2$)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr><tr><td>快速排序</td><td>O($n(log_{2}n)$)</td><td>O(n2)</td><td>不稳定</td><td>O($n(logn)$)</td><td>n 大时较好</td></tr><tr><td>归并排序</td><td>O($n(log_{2}n)$)</td><td>O($n(log_{2}n)$)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr><td>堆排序</td><td>O($n(log_{2}n)$)</td><td>O($n(log_{2}n)$)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr></tbody></table></div><p><strong>稳定性：</strong>排序后，那些原本相等元素的相对顺序不改变</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-4 程序控制结构</title>
      <link href="/2023/01/23/Java-%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2023/01/23/Java-%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><blockquote><p>程序运行的流程控制决定程序是如何执行的，是我们必须掌握的。主要分为：顺序控制、分支控制、循环控制。</p></blockquote><h2 id="1-顺序控制"><a href="#1-顺序控制" class="headerlink" title="1 顺序控制"></a>1 顺序控制</h2><blockquote><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p><p>比如：Java 定义变量时采用合法的前向引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(A语句)--&gt;B(B语句)--&gt;C(C语句)--&gt;D(D语句)--&gt;E(...)</span><br></pre></td></tr></table></figure></blockquote><p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p><ul><li><p>单语句：通常意义的一条语句。语句间以分号 <code>;</code> 分隔。</p></li><li><p>复合语句：一对大括号括起来的语句组。也称为 “块”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>; </span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块中可以有多条语句。块后没有分号 <code>;</code></p></li></ul><h2 id="2-分支控制-if-else"><a href="#2-分支控制-if-else" class="headerlink" title="2 分支控制 if-else"></a>2 分支控制 <code>if-else</code></h2><blockquote><p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p></blockquote><h3 id="2-1-单分支控制"><a href="#2-1-单分支控制" class="headerlink" title="2.1 单分支控制"></a>2.1 单分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) 语句;</span><br></pre></td></tr></table></figure><p>特别地，把代码块（复合语句）作为语句的场合也能这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行 <code>&#123;执行代码块;&#125;</code>；如果为 <code>false</code> 则不执行。特别地：如果 <code>&#123;执行代码块;&#125;</code> 中只有一条代码，也可以不写 <code>&#123; &#125;</code>（但还是建议写上）</p><h3 id="2-2-双分支控制"><a href="#2-2-双分支控制" class="headerlink" title="2.2 双分支控制"></a>2.2 双分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 执行代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行 <code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行 <code>&#123;执行代码块2;&#125;</code>。</p><h3 id="2-3-多分支控制"><a href="#2-3-多分支控制" class="headerlink" title="2.3 多分支控制"></a>2.3 多分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>) &#123;</span><br><span class="line"> 执行代码块<span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">3</span>) &#123;</span><br><span class="line"> 执行代码块<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> 执行代码块n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别地：多分支可以没有 <code>else</code>。此时如果条件都不成立，则无执行入口</p><h3 id="2-4-嵌套分支"><a href="#2-4-嵌套分支" class="headerlink" title="2.4 嵌套分支"></a>2.4 嵌套分支</h3><blockquote><p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p></blockquote><p>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if 语句：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) n++;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) n++;</span><br><span class="line"><span class="keyword">else</span> n--;<span class="comment">//属于上面这个 if 语句</span></span><br></pre></td></tr></table></figure><blockquote><p>这个场合，这个 else 语句属于上面的 <code>if (n &gt; 1)</code> 这个语句</p></blockquote></blockquote><p>要想改变那个匹配关系，要使用 <code>&#123; &#125;</code> 改变语句结构：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n++;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) n++;  </span><br><span class="line">&#125; <span class="keyword">else</span> n--;</span><br></pre></td></tr></table></figure></blockquote><p><strong>规范：嵌套尽量不超过 3 层（可读性不好）</strong></p><h2 id="3-switch-分支结构"><a href="#3-switch-分支结构" class="headerlink" title="3 switch 分支结构"></a>3 <code>switch</code> 分支结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//break 语句可选</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//break 语句可选</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//default 语句可选</span></span><br><span class="line"><span class="keyword">default</span>语句块;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//break 语句可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>switch</code> 关键字，表示 switch 分支。</li><li><code>表达式</code> 对应一个值。<strong>该值必须是 int 或 char</strong>（char 可以转化为 int）。是 byte 或 short 的场合，要提升为 int。不允许 long、double 或 float</li><li><code>case 常量1;</code> 表示：当 <code>表达式</code> 的值等于 <code>常量1</code> ，则执行 <code>语句块1</code>。</li><li><code>break;</code> 表示退出 switch 分支。</li><li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行 <code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2</code> ，以此类推。</li><li>如果全都不匹配，则执行 <code>default</code>。</li><li>如果不写 <code>break;</code> ，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li></ol><h3 id="3-1-使用细节"><a href="#3-1-使用细节" class="headerlink" title="3.1 使用细节"></a>3.1 使用细节</h3><ol><li><code>表达式;</code> 数据类型，应和 <code>case</code> 后的 <code>常量</code> 类型一致，或者是可以自动转换成可以比较的类型。如：输入的是 <code>char</code> 而 <code>常量</code> 是 <code>int</code></li><li>switch 中 <code>表达式</code> 的返回值必须是：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>enum</code> <code>String</code></li><li><code>case</code> 语句中的值必须是 常量 或 常量表达式，不能是 变量。</li><li><code>default</code> 是可选的。没有就不执行。</li><li><code>break;</code> 用来跳出 switch 分支。如果不写，会持续执行语句，直到分支结束或遇到下一个 <code>break;</code></li></ol><h3 id="3-2-与-if-else-分支结构的取舍"><a href="#3-2-与-if-else-分支结构的取舍" class="headerlink" title="3.2 与 if-else 分支结构的取舍"></a>3.2 与 <code>if-else</code> 分支结构的取舍</h3><ul><li>如果判断的具体数值不多，且符合 3.1中的1 ，推荐使用 switch。</li><li>对区间判断的场合，对结果为 boolean 类型的判断，使用 <code>if-else</code>。</li></ul><h2 id="4-for-循环控制"><a href="#4-for-循环控制" class="headerlink" title="4 for 循环控制"></a>4 <code>for</code> 循环控制</h2><blockquote><p>让代码可以循环执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量初始化;循环条件;循环变量迭代)&#123;</span><br><span class="line">循环操作（代码块）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>for</code> 关键字，表示循环控制</li><li>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4. 循环变量迭代</li></ul><p>所有循环开始前仅一次进行初始化。直到循环条件变为 false 前，执行循环操作。每轮循环结束后，进行循环变量迭代。</p><ul><li>循环操作可以有多条语句</li><li>如果循环操作只有一条语句，可以省略 <code>&quot; &quot;</code>，但建议不省略</li></ul><h3 id="4-1-使用细节"><a href="#4-1-使用细节" class="headerlink" title="4.1 使用细节"></a>4.1 使用细节</h3><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>循环条件可以为空。这个场合，默认为真（true）</p></li><li><p><code>for(;循环条件;)&#123; &#125;</code> 其中的初始化和变量迭代可以写在别处，但 <code>;</code> 不能省略。如果不写在别处，那个 <code>循环变量初始化</code> 中声明的变量只能在该 for 循环中使用。</p></li><li><p>控制台用 ctrl + c 强制结束一个流程</p></li><li><p>循环初始值可以有多条初始化语句，但要求类型一样，并用 <code>,</code> 隔开。</p><p>变量迭代也可以有多条代码，用 <code>,</code> 隔开。</p></li></ol><h3 id="4-2-for-each（泛型-for-循环）"><a href="#4-2-for-each（泛型-for-循环）" class="headerlink" title="4.2 for each（泛型 for 循环）"></a>4.2 for each（泛型 for 循环）</h3><blockquote><p>泛型 for 循环（增强 for 循环）能用来依次处理数组（或其他元素集合）中的每个元素，而不必考虑下标值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;<span class="comment">//其中 nums 是一个一维 int 数组</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述写法（增强 <code>for</code> 写法）类似于以下写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型 for 循环适用于数组或一个实现了 Iterable 接口的对象。泛型 for 循环的本质是一个 Iterator（迭代器）</p><h2 id="5-while-循环控制"><a href="#5-while-循环控制" class="headerlink" title="5 while 循环控制"></a>5 <code>while</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line"> 循环体(代码块);</span><br><span class="line"> 循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同</p><h3 id="5-1-使用细节"><a href="#5-1-使用细节" class="headerlink" title="5.1 使用细节"></a>5.1 使用细节</h3><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>while 循环中，循环条件不能为空。</p></li><li><p><code>while</code> 循环是先判断再执行语句。</p></li></ol><h2 id="6-do-while-循环控制"><a href="#6-do-while-循环控制" class="headerlink" title="6 do..while 循环控制"></a>6 <code>do..while</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体;</span><br><span class="line">循环变量迭代;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure><ol><li><code>do</code> <code>while</code> 是关键字</li><li>也有四要素，位置不同</li><li>先执行，再判断。也就是说，一定会至少执行一次</li><li><strong>最后有一个 <code>;</code></strong></li><li><code>while</code> 与 <code>do..while</code> 区别：”要账”</li></ol><h3 id="6-1-使用细节"><a href="#6-1-使用细节" class="headerlink" title="6.1 使用细节"></a>6.1 使用细节</h3><ol><li>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</li><li><code>do..while</code> 循环是先执行再判断的语句。因此至少执行一次。</li></ol><h2 id="7-多重循环控制"><a href="#7-多重循环控制" class="headerlink" title="7 多重循环控制"></a>7 多重循环控制</h2><p>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。嵌套循环 是把 内层循环 当成 外层循环 的 循环体。只有内层 <code>false</code> 时才可能结束当层循环。若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</p><blockquote><p>以下是一个示例（乘法口诀）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code4_7</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//声明第一个乘数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//声明第二个乘数</span></span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           <span class="comment">//直到 a &gt; b 为止，a 不断增长，并让两数相乘，输出公式</span></span><br><span class="line">           <span class="keyword">do</span>&#123;</span><br><span class="line">               System.out.print(a + <span class="string">&quot; * &quot;</span> + b + <span class="string">&quot; = &quot;</span> + a * b </span><br><span class="line">               + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">               a++;</span><br><span class="line">           &#125;<span class="keyword">while</span>(a &lt;= b);</span><br><span class="line">       <span class="comment">//把 a 重置为 1，让 b 增长，然后循环</span></span><br><span class="line">       a = <span class="number">1</span>;</span><br><span class="line">       System.out.println();</span><br><span class="line">       b++;</span><br><span class="line">       &#125;<span class="keyword">while</span>(b &lt;= <span class="number">9</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="8-跳转控制语句"><a href="#8-跳转控制语句" class="headerlink" title="8 跳转控制语句"></a>8 跳转控制语句</h2><blockquote><p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p></blockquote><h3 id="8-1-标签"><a href="#8-1-标签" class="headerlink" title="8.1 标签"></a>8.1 标签</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a:&#123;</span><br><span class="line">b:&#123;</span><br><span class="line">c:&#123;</span><br><span class="line">   ...</span><br><span class="line"> berak b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>a:</code> <code>b:</code> <code>c:</code> 是标签，名字由程序员指定</li><li><code>break</code> 后指定哪个标签就退出到哪里</li><li><strong>实际开发中，尽量不要使用标签</strong></li></ol><h3 id="8-2-break"><a href="#8-2-break" class="headerlink" title="8.2 break"></a>8.2 break</h3><blockquote><p>用于中止一个语句块的执行</p></blockquote><p>语法：<code>break;</code></p><p>break 可以被用在三种场合中</p><ul><li><p>switch 语句中，以跳出判断（结束穿透）</p></li><li><p>for、while、do…while 循环语句中，以跳出循环</p></li><li><p>语句块中，以跳过本块中所有剩余语句</p><p><code>break</code> 语句出现在多层嵌套的语句块中时，可以通过 <strong>标签</strong> 指明要终止的时哪一层语句块。</p></li></ul><h3 id="8-3-continue"><a href="#8-3-continue" class="headerlink" title="8.3 continue"></a>8.3 continue</h3><blockquote><p>在循环中出现。用于结束本次循环，继续下一次循环</p></blockquote><p>语法：<code>continue;</code></p><p>进行下次循环前，仍会判断循环条件是否满足</p><p>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同 <code>break</code>）</p><h3 id="8-4-return"><a href="#8-4-return" class="headerlink" title="8.4 return"></a>8.4 return</h3><blockquote><p> 用于方法。表示跳出所在的方法</p></blockquote><p>语法：<code>return;</code></p><p>方法有返回值的场合，将返回值写在 return 后：<code>return 值;</code></p><p>如果写在 主方法 则跳出程序</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-3 运算符</title>
      <link href="/2023/01/22/Java-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2023/01/22/Java-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><blockquote><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等</p></blockquote><h2 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1 算数运算符"></a>1 算数运算符</h2><blockquote><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java 程序中使用得非常多。其运算结果是一个数值量。</p></blockquote><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code> ：加（正）、减（负）、乘、除</p><blockquote><p><code>5 / 2 = 2;</code> 因为是 <code>int</code>。同理 <code>5.0 / 2 = 2.5</code></p></blockquote></li><li><p><code>%</code> ：取模（求余数），结果和被取模数同号。其实 <code>a % b == a - (int)a / b * b;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> % <span class="number">9</span> = <span class="number">2</span>;</span><br><span class="line">-<span class="number">11</span> % <span class="number">9</span> = -<span class="number">2</span>;</span><br><span class="line"><span class="number">11</span> % -<span class="number">9</span> = <span class="number">2</span>;</span><br><span class="line">-<span class="number">11</span> % -<span class="number">9</span> = -<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>++</code> ：自增</p><p><code>++i</code> 先自增后赋值；<code>i++</code> 先赋值后自增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ++i; <span class="comment">//等价于 i = i + 1; j = i; 此时 i = 10; j = 10`</span></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i++; <span class="comment">//等价于 k = i; i = i + 1; 此时 i = 11; k = 10`</span></span><br><span class="line">i = i++; <span class="comment">//系统会先后执行 int temp = i;     i = i + 1;     i = temp</span></span><br><span class="line">i = ++i; <span class="comment">//系统会先后执行 i = i + 1;     int temp = i;     i = temp</span></span><br></pre></td></tr></table></figure></li><li><p><code>--</code> ：自减。和 <code>++</code> 同理</p></li><li><p><code>+</code> ：字符串相加</p></li></ul><h2 id="2-关系运算符（比较运算符）"><a href="#2-关系运算符（比较运算符）" class="headerlink" title="2 关系运算符（比较运算符）"></a>2 关系运算符（比较运算符）</h2><blockquote><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>ture</code> 要么是 <code>false</code>。其关系表达式经常用在 <code>if</code> 结构的条件中或循环结构的条件中。</p></blockquote><ul><li><code>==</code> ：相等于。<code>8 == 7</code> 结果 <code>false</code></li><li><code>!=</code> ：不等于</li><li><code>&lt;</code> <code>&gt;</code> ：小于、大于</li><li><code>&lt;=</code> <code>&gt;=</code> ：小于等于、大于等于</li><li><code>instanceof</code> ：检查是否是类的对象。<code>&quot;a&quot; istanceof String</code> 结果 <code>ture</code></li></ul><h3 id="2-1-使用细节"><a href="#2-1-使用细节" class="headerlink" title="2.1 使用细节"></a>2.1 使用细节</h3><ol><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>ture</code> ，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li><li>Java 允许将 <code>==</code>、<code>!=</code> 两种运算用于任何数据类型</li></ol><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3 逻辑运算符"></a>3 逻辑运算符</h2><blockquote><p>用于连接多个条件（多个关系表达式），最终的结果也是一个 <code>boolean</code> 值</p></blockquote><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code> 同时为 <code>ture</code>，则结果为 <code>ture</code>，否则为 <code>false</code></p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为 <code>ture</code>，则结果为 <code>ture</code>，否则为 <code>false</code></p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于 <code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则 <code>b</code> 不判断。而 <code>&amp;</code> 会完成判断。开发中多用 <code>&amp;&amp;</code> ，因为其效率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a++ &gt; <span class="number">1</span> &amp;&amp; ++b &lt; <span class="number">1</span>) System.out.println(<span class="string">&quot;Nothing happened&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此时 a 经历了先判断后自增，返回 false 并且 a = 2</span></span><br><span class="line"><span class="comment">但此时 b = 1; 因为 a = false; 所以 ++b 不执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为 <code>ture</code>，则结果为 <code>ture</code>，否则为 <code>false</code></p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为 <code>ture</code>，则结果为 <code>ture</code>，否则为 <code>false</code></p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code> 相似，若第一个为 <code>ture</code> ，则 <code>||</code> 不会判断第二个</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为 <code>ture</code>，则结果为 <code>false</code>。反之为 <code>ture</code></p></li><li><code>^</code>：逻辑异或。<code>a</code> <code>b</code> 不同时，结果为 <code>ture</code>，否则为 <code>false</code></li></ul><h2 id="4-赋值运算符"><a href="#4-赋值运算符" class="headerlink" title="4 赋值运算符"></a>4 赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>符合赋值运算符：<code>+=</code> ; <code>-=</code> ; <code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理</p></blockquote></li></ul><h3 id="4-1-使用细节"><a href="#4-1-使用细节" class="headerlink" title="4.1 使用细节"></a>4.1 使用细节</h3><ol><li><p>运算顺序从右往左。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> a + b + c;<span class="comment">// 先运行(a + b + c)，再结算int num =</span></span><br></pre></td></tr></table></figure></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; b += <span class="number">3</span>;<span class="comment">// 此时 b += 3 等价于 b = (byte)(b + 3)</span></span><br><span class="line">b++;<span class="comment">// 同理</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="5-三元运算符"><a href="#5-三元运算符" class="headerlink" title="5 三元运算符"></a>5 三元运算符</h2><blockquote><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code> ，运算的结果是表达式1；反之为表达式2。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (a == b ? a++ : b++);<span class="comment">// 此时 a = 10  result = 11  b = 12</span></span><br></pre></td></tr></table></figure><h3 id="5-1-使用细节"><a href="#5-1-使用细节" class="headerlink" title="5.1 使用细节"></a>5.1 使用细节</h3><ol><li><p>表达式1 和 表达式2 要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</p></li><li><p>三元运算符可以转成 <code>if--else</code></p></li><li><p>三元运算符是一个整体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.2</span>);</span><br><span class="line">System.out.print(obj)</span><br></pre></td></tr></table></figure><p>上例中，系统将会输出 <code>1.0</code></p><p>因为 三元运算符 是一个整体，所以发生了类型转换。</p></li></ol><h2 id="6-运算符优先级"><a href="#6-运算符优先级" class="headerlink" title="6 运算符优先级"></a>6 运算符优先级</h2><p><a href="http://c.biancheng.net/view/794.html">Java运算符优先级 (biancheng.net)</a></p><div class="table-container"><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>()、[]、{}</td><td>从左向右</td></tr><tr><td>2</td><td>!、+、-、~、++、—</td><td>从右向左</td></tr><tr><td>3</td><td>*、/、%</td><td>从左向右</td></tr><tr><td>4</td><td>+、-</td><td>从左向右</td></tr><tr><td>5</td><td>«、»、&gt;&gt;&gt;</td><td>从左向右</td></tr><tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td><td>从左向右</td></tr><tr><td>7</td><td>==、!=</td><td>从左向右</td></tr><tr><td>8</td><td>&amp;</td><td>从左向右</td></tr><tr><td>9</td><td>^</td><td>从左向右</td></tr><tr><td>10</td><td>\</td><td></td><td>从左向右</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>从左向右</td></tr><tr><td>12</td><td>\</td><td>\</td><td></td><td>从左向右</td></tr><tr><td>13</td><td>?:</td><td>从右向左</td></tr><tr><td>14</td><td>=、+=、-=、*=、/=、&amp;=、\</td><td>=、^=、~=、«=、»=、&gt;&gt;&gt;=</td><td>从右向左</td></tr></tbody></table></div><ol><li>运算符有不同优先级。优先级高的总是优先于低的。</li><li>只有单目运算符、赋值运算符是从右向左运算的。</li></ol><h2 id="7-标识符"><a href="#7-标识符" class="headerlink" title="7 标识符"></a>7 标识符</h2><blockquote><p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符</p><p>凡是自己可以起名字的地方都叫标识符 <code>double height = 0.0;</code></p></blockquote><h3 id="7-1-命名规则"><a href="#7-1-命名规则" class="headerlink" title="7.1 命名规则"></a>7.1 命名规则</h3><ol><li><p>标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $ 符号组成。</p></li><li><p><strong>数字不能开头</strong>。 错误示范：<code>int 3a = 1;</code></p></li><li><p>不能使用关键字和保留字（可以包含）。</p></li><li><p>严格区分大小写，长度无限制。</p></li><li><p>不能包含空格。</p></li><li><p>与多数编程语言不同。Java 可以用任何 Unicode 字符（特殊字符除外）作为标识符。但不推荐这么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ᓚᘏᗢ = <span class="string">&quot;✪ ω ✪&quot;</span>;<span class="comment">// 喵？</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="7-2-命名规范"><a href="#7-2-命名规范" class="headerlink" title="7.2 命名规范"></a>7.2 命名规范</h3><ol><li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc</li><li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li><li>更详细的规则查看 <a href="https://developer.aliyun.com/article/709470">Java 编码规范</a></li></ol><h2 id="8-输入与输出"><a href="#8-输入与输出" class="headerlink" title="8 输入与输出"></a>8 输入与输出</h2><blockquote><p>为满足读取用户输入、输出的需求，Java 提供了几个基本类</p></blockquote><h3 id="8-1-Scanner-类"><a href="#8-1-Scanner-类" class="headerlink" title="8.1 Scanner 类"></a>8.1 Scanner 类</h3><blockquote><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。</p><p><code>Input.java</code> ，需要一个 扫描器（对象），就是 Scanner</p><p>Scanner 属于 java.util 包。其包含许多方法</p></blockquote><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//[1] 导入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code3_8_1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">aScannerName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//[2] 创建 Scanner 对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;\n输入点什么吧！&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pointSomething</span> <span class="operator">=</span> aScannerName.next();<span class="comment">//[3] 接收用户输入</span></span><br><span class="line">    System.out.println(<span class="string">&quot;\n接下来，输入一个数字吧！&quot;</span>);</span><br><span class="line">    <span class="type">double</span> <span class="variable">aNumber</span> <span class="operator">=</span> aScannerName.nextDouble();<span class="comment">//[3] 接收用户输入</span></span><br><span class="line">    System.out.println(<span class="string">&quot;\n你输入的\&quot;点什么\&quot;是:\&quot;&quot;</span> </span><br><span class="line">    + pointSomething + <span class="string">&quot;\&quot;\n你输入的\&quot;一个数字\&quot;是：\&quot;&quot;</span> </span><br><span class="line">    + aNumber + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>导入该类所在的包</li><li>创建该类对象（声明变量）</li><li>调用里面的功能，接收用户输入</li></ol></blockquote><p>构造方法：</p><ul><li><code>new Scanner(System.in)</code>：该方法接收一个参数（输入源）。其中 <code>System.in</code> 代表标准输入流。默认情况指键盘。</li></ul><p>常用方法：</p><ul><li><p><code>String next()</code>：读取下一个输入对象</p><p>Scanner 对象用空白（空格、水平制表符或回车换行符）作为输入的分隔元素</p></li><li><p><code>Double nextDouble()</code>：读取下一个 double</p></li><li><p><code>Int nextInt()</code>：读取下一个 int</p></li><li><p><code>String nextLine()</code>：读入当前行的所有输入，直到行尾</p></li><li><p><code>boolean hasNext()</code>：输入中是否还有其他单词</p></li><li><p><code>boolean hasNextInt()</code></p></li><li><p><code>boolean hasNextDouble()</code></p></li></ul><h3 id="8-2-格式化输出"><a href="#8-2-格式化输出" class="headerlink" title="8.2 格式化输出"></a>8.2 格式化输出</h3><blockquote><p>System.out 标准输出流。调用该流方法以输出内容至控制台窗口</p></blockquote><ul><li><code>println(String s)</code>：输出字符，结束后换行</li><li><code>print(String s)</code>：输出字符，结束后不换行</li><li><code>printf(String format, Object ... args)</code>：格式化输出</li></ul><p>以 % 开头的 <em>格式说明符</em> 都用相应参数替换。格式说明符尾部的转换符表示要格式化的数值类型</p><div class="table-container"><table><thead><tr><th>转换符</th><th>类型</th><th style="text-align:center"></th><th>转换符</th><th>类型</th></tr></thead><tbody><tr><td>d</td><td>十进制整数</td><td style="text-align:center"></td><td>s</td><td>字符串</td></tr><tr><td>x</td><td>十六进制整数</td><td style="text-align:center"></td><td>c</td><td>字符</td></tr><tr><td>o</td><td>八进制整数</td><td style="text-align:center"></td><td>b</td><td>布尔值</td></tr><tr><td>f</td><td>定点浮点数</td><td style="text-align:center"></td><td>h</td><td>散列码</td></tr><tr><td>e</td><td>指数浮点数</td><td style="text-align:center"></td><td>tx 或 Tx</td><td>日期时间（T强制大写）</td></tr><tr><td>g</td><td>通用浮点数</td><td style="text-align:center"></td><td>%</td><td>百分号</td></tr><tr><td>a</td><td>十六进制浮点数</td><td style="text-align:center"></td><td>n</td><td>行分隔符</td></tr></tbody></table></div><p>也能指定控制格式化输出外观的各种标志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;% (4.12f&quot;</span>, Math.PI);<span class="comment">// &lt;————— 保留 12 位，正数添加空格，负数添加括号</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>标志</th><th>目的</th></tr></thead><tbody><tr><td>+</td><td>打印正数和负数的符号</td></tr><tr><td>（空格）</td><td>在正数前添加空格</td></tr><tr><td>0</td><td>数字前面补 0</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>(</td><td>负号被括号环绕</td></tr><tr><td>,</td><td>添加分组分隔符</td></tr><tr><td>#（对于 f 格式）</td><td>包含小数点</td></tr><tr><td>#（对于 x 或 0 格式）</td><td>添加前缀 0x 或 0</td></tr><tr><td>$</td><td>指定要格式化的参数索引：%1$d 以十进制打印第 1 个参数</td></tr><tr><td>&lt;</td><td>格式化前面说明的数值：%d%&lt;x 十进制打印后，再以十六进制打印一遍</td></tr></tbody></table></div><h3 id="8-3-NumberFormat-类"><a href="#8-3-NumberFormat-类" class="headerlink" title="8.3 NumberFormat 类"></a>8.3 NumberFormat 类</h3><blockquote><p>Java 提供的格式化输出功能，能使打印或显示是信息更美观</p><p>NumberFormat 类属于 Java 标准类库，在 java.text 包中</p><p>NumberFormat 类不能直接创建对象。利用类中的静态方法获取一个对象实例</p></blockquote><p>获取实例：</p><ul><li><code>NumberFormat.getInstance()</code>：返回当前默认语言环境的默认数值格式</li><li><code>NumberFormat.getCurrnecyInstance()</code>：返回当前默认语言环境的通用格式</li><li><code>NumberFormat.getNumberInstance()</code>：返回当前默认语言环境的通用数值格式</li><li><code>NumberFormat.getPercentInstance()</code>：返回当前默认语言环境的百分比格式</li></ul><p>常用方法：</p><ul><li><code>format(num)</code>：获取 num 的格式化语句</li><li><code>setMaximunFactionDigits(n)</code>：将该格式的小数部分允许的最大位数设置为 n</li><li><code>setMinimunFactionDigits(n)</code>：将该格式的小数部分允许的最小位数设置为 n</li><li><code>setMaximunIntegerDigits(n)</code>：将该格式的整数部分允许的最大位数设置为 n</li><li><code>setMinimunIntegerDigits(n)</code>：将该格式的整数部分允许的最小位数设置为 n</li></ul><h3 id="8-4-DecimalFormat-类"><a href="#8-4-DecimalFormat-类" class="headerlink" title="8.4 DecimalFormat 类"></a>8.4 DecimalFormat 类</h3><blockquote><p>与 NumberFormat 类不同，DecimalFormat 类可以直接实例化对象。</p></blockquote><p>实例化：</p><ul><li><p><code>new DecimalFormat(pattern)</code></p><p>其中 pattern 是一个 String，代表格式化处理模式。如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.###&quot;</span>);<span class="comment">//格式对象，保留 3 位小数</span></span><br></pre></td></tr></table></figure></li></ul><p>常用方法：</p><ul><li><code>format(num)</code>：获取 num 的格式化语句</li><li><code>applyPattern(pattern)</code>：变更要使用的格式</li></ul><h2 id="9-进制"><a href="#9-进制" class="headerlink" title="9 进制"></a>9 进制</h2><ul><li>二进制：数字有 0 - 1，满 2 进 1，以 <code>0b</code> 或 <code>0B</code> 开头</li><li>十进制</li><li>八进制：0 - 7，满 8 进 1，以 <code>0</code> 开头表示</li><li>十六进制：0 - 9 及 A - F，满 16 进 1，以<code>0x</code> 或 <code>0X</code> 开头。此处的 A - F 不分大小写。</li></ul><h3 id="9-1-进制的转换"><a href="#9-1-进制的转换" class="headerlink" title="9.1 进制的转换"></a>9.1 进制的转换</h3><ul><li>其他进制 转 十进制：略</li><li>十进制 转 其他进制：将该数不断除以对象进制数，直到商为0为止，将每步得到的余数倒过来。</li><li>二进制 与 八进制 或 十六进制 互相转换：二进制 从低位开始，每 3 位一组，转成对应的 八进制 即可。反之同理。十六进制亦同理（每 4 位一组）。</li></ul><h3 id="9-2-原码、反码、补码"><a href="#9-2-原码、反码、补码" class="headerlink" title="9.2 原码、反码、补码"></a>9.2 原码、反码、补码</h3><p>对于有符号数而言：</p><ol><li>二进制的最高位是符号位：0表示正数，1表示负数。</li><li>正数的原码、反码、补码都一样。</li><li>负数的反码 = 原码符号位不变，其他位取反（0 变 1，1 变 0）</li><li><strong>负数的补码 = 反码 + 1。也就是说，负数的反码 = 补码 - 1。</strong></li><li>0 的反码、补码都是 0。</li><li>Java 没有无符号数。换言之，Java 的数都是有符号的。</li><li><strong>计算机运算时，都是以补码的方式来运算的。</strong></li><li><strong>当我们看运算结果时，要看其原码。</strong></li></ol><h2 id="10-位运算符"><a href="#10-位运算符" class="headerlink" title="10 位运算符"></a>10 位运算符</h2><ul><li><p><code>&amp;</code> 按位与：两位都为 1，结果为 1，否则为 0</p></li><li><p><code>|</code> 按位或：两位有一个为 1，结果为 1，否则为 0</p></li><li><p><code>^</code> 按位异或：两位不同，结果为 1，否则为 0</p></li><li><p><code>~</code> 按位取反：把 0 变 1，1 变 0</p><p>以下是几个示例：</p><ul><li><p><code>2 &amp; 3</code>：</p><blockquote><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>3 的原码：00000000 00000000 00000000 00000011</p><p>3 的补码：00000000 00000000 00000000 00000011</p><p>补码运算结果：00000000 00000000 00000000 00000010</p><p>结果转成原码：00000000 00000000 00000000 00000010</p><p>运算结果：2</p></blockquote></li><li><p><code>~-2</code>：</p><blockquote><p>得到 -2 的原码：10000000 00000000 00000000 00000010</p><p>得到 -2 的反码：11111111 11111111 11111111 11111101</p><p>得到 -2 的补码：11111111 11111111 11111111 11111110</p><p>补码运算结果：00000000 00000000 00000000 00000001</p><p>结果转成原码：00000000 00000000 00000000 00000001</p><p>运算结果：1</p></blockquote></li><li><p><code>~2</code>：</p><blockquote><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>补码运算：11111111 11111111 11111111 11111101</p><p>结果转成反码：11111111 11111111 11111111 11111100</p><p>反码转成原码：10000000 00000000 00000000 00000011</p><p>运算结果：-3</p></blockquote></li></ul></li><li><p><code>&gt;&gt;</code> 算术右移：低位溢出，符号位不变，用符号位补溢出的高位</p></li><li><p><code>&lt;&lt;</code> 算数左移：符号位不变，低位补 0</p></li><li><p><code>&gt;&gt;&gt;</code> 逻辑右移（无符号右移）：低位溢出，高位补 0</p><p>下面是示例：</p><ul><li><p>将数字 1 算术右移 2 位：<code>int a = 1 &gt;&gt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000000</p><p>结果：00000000 00000000 00000000 00000000</p></blockquote></li><li><p>将数字 1 算术左移 2 位：<code>int b = 1 &lt;&lt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000100</p><p>结果：00000000 00000000 00000000 00000100</p></blockquote></li></ul><p>也就是说，<code>1 &lt;&lt; 2</code> 本质是 <code>1 * 2 * 2 = 4</code></p><p>而 <code>1 &gt;&gt; 2</code> 本质是 <code>1 / 2 / 2 = 0</code></p></li></ul><p><strong>使用细节：</strong></p><ol><li><p>位运算符只对整型、字符类型有效</p></li><li><p>移位运算中，左侧操作 int 的场合，右侧操作数以 32 取模；long 的场合，右侧操作数以 64 取模</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">n &gt;&gt;= <span class="number">32</span>;<span class="comment">//这个场合，n 不改变。这样能保证左侧数字不被全部移走</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Java-API-文档"><a href="#Java-API-文档" class="headerlink" title="Java API 文档"></a>Java API 文档</h3><blockquote><p>API：Application Programming Iterface（应用程序编程接口），是 Java 提供的基本编程接口（Java 提供的一些类和方法）。</p><p>Java 语言提供了大量基础类，为了告诉开发者如何使用这些类，及类里包含的方法，就有了API文档。<a href="https://www.matools.com/api/java8">Java8-API中文手册</a></p></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><p>包 —— 类 / 接口 —— 方法</p></li><li><p>直接检索</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-2 变量</title>
      <link href="/2023/01/22/Java-%E5%8F%98%E9%87%8F/"/>
      <url>/2023/01/22/Java-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote><p>变量：变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><p>示例：<code>int a = 1</code> 类型 int 名称 a 值 1</p></blockquote><p><strong>如何声明变量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span>, d;</span><br></pre></td></tr></table></figure><h2 id="1-变量使用注意事项"><a href="#1-变量使用注意事项" class="headerlink" title="1 变量使用注意事项"></a>1 变量使用注意事项</h2><ol><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如 <code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte</li><li>该区域有自己的名称 <code>变量名</code> 和类型 <code>数据类型</code></li><li>变量必须先声明，后使用</li><li>变量在同一作用域内不能重名</li><li>该区域的数据 · 值可以在同一类型范围内变化</li><li>变量的三个基本要素：类型 + 名称 + 值</li></ol><h2 id="2-程序中-的使用"><a href="#2-程序中-的使用" class="headerlink" title="2 程序中 + 的使用"></a>2 程序中 <code>+</code> 的使用</h2><ol><li>当左右两边都是数值型，做加法运算</li><li>当左右两边任意一方为字符串，做拼接运算</li><li>运算顺序是从左到右的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="number">1</span> + <span class="string">&quot;a&quot;</span> + <span class="number">1</span> + <span class="number">1</span>);<span class="comment">// 输出 2a11</span></span><br></pre></td></tr></table></figure><h2 id="3-Java-数据类型"><a href="#3-Java-数据类型" class="headerlink" title="3 Java 数据类型"></a>3 Java 数据类型</h2><h3 id="3-1-基本数据类型（本章）"><a href="#3-1-基本数据类型（本章）" class="headerlink" title="3.1 基本数据类型（本章）"></a>3.1 基本数据类型（本章）</h3><ul><li><strong>数值型</strong><ul><li>整数类型:<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><strong>字符型</strong><ul><li><strong>char：存放单个字符，占用 2 字节</strong></li></ul></li><li><strong>布尔型</strong><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h3 id="3-2-引用数据类型（复合数据类型）"><a href="#3-2-引用数据类型（复合数据类型）" class="headerlink" title="3.2 引用数据类型（复合数据类型）"></a>3.2 引用数据类型（复合数据类型）</h3><ul><li><strong>类</strong>：class</li><li><strong>接口</strong>：interface</li><li><strong>数组</strong>：<code>[]</code></li></ul><h2 id="4-整数类型"><a href="#4-整数类型" class="headerlink" title="4 整数类型"></a>4 整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 $-2^{15}到2^{15} - 1$</li><li><code>int</code> 占用 4 字节，范围 $-2^{31}到2^{31} - 1$</li><li><code>long</code> 占用 8 字节，范围 $-2^{63}到2^{63} - 1$</li></ul><p><strong>使用细节：</strong></p><ol><li>Java 各整数类型有固定的范围和字符长度，不受具体 OS（操作系统）影响，以保证 Java 程序的可移植性</li><li>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code> 型常量必须后加 <code>l</code> 或 <code>L</code></li><li>从 Java 7 开始，加上前缀 <code>0b</code> 或 <code>0B</code> 就可以写二进制数</li><li>从 Java 7 开始，可以为数字字面添加下划线。这不会影响数字的值，只是为了方便阅读</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0b0010</span>;</span><br><span class="line">n = <span class="number">0b001</span>;</span><br><span class="line">n = <span class="number">100_0_000000</span>;</span><br><span class="line">n = <span class="number">0B0000_0010_1100</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.0F</span>;</span><br></pre></td></tr></table></figure><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用 “大数”</p><h2 id="5-浮点类型"><a href="#5-浮点类型" class="headerlink" title="5 浮点类型"></a>5 浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约 -3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约 -1.798E308 ~ 1.798E308</li></ul><p><em>浮点数在机器中存放形式为：浮点数 = 符号位 + 指数位 + 尾数位</em></p><p><strong><em>因此，尾数部分可能丢失，造成精度损失。换言之，小数都是近似值</em></strong></p><h3 id="5-1-使用细节"><a href="#5-1-使用细节" class="headerlink" title="5.1 使用细节"></a>5.1 使用细节</h3><ol><li><p>与整数类型相似，有固定的范围和字符长度，不受具体 OS（操作系统）影响</p></li><li><p>Java 默认浮点常量为 <code>double</code> ，要声明 <code>float</code> 型常量必须后加 ”f“ 或 ”F“</p></li><li><p>浮点型常量有两种表示形式</p><blockquote><p>十进制数形式：<code>5.13</code>、<code>315.4F</code>、<code>.414</code></p><p>科学计数法：<code>5.12e2</code> 即[5.12 × 102]、<code>5.12E-2</code> 即[5.12 / 102]</p></blockquote></li><li><p>通常情况下，应该使用 <code>double</code> 类型，以其更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相对判断时，要小心。（因为<strong><em>小数都是近似值</em></strong>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Math.abs(num1 - num2) &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;插值范围内认为相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特殊的浮点类型常量</p><ol><li><p>正无穷大：<code>Float.POSITIVE_INFINITY</code>、<code>Double.POSITIVE_INFINITY</code></p><p>（浮点数运算中）一个正数除以 0，会得到该值</p></li><li><p>负无穷大：<code>Float.NEGATIVE_INFINITY</code>、<code>Double.NEGATIVE_INFINITY</code></p><p>（浮点数运算中）一个负数除以 0，会得到该值</p></li><li><p>0 / 0：<code>Float.NaN</code>、<code>Double.NaN</code></p><p>（浮点数运算中）0 除以 0，会得到该值</p></li><li><p>最大、最小值：<code>Float.MAX_VALUE</code>、<code>Double.MIN_VALUE</code></p></li></ol></li><li><p>不能用运算符来比较特殊值，而要用特别的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0.0</span> / <span class="number">0</span>;</span><br><span class="line">System.out.println(num == Double.NaN);<span class="comment">// &lt;——— 始终为 false。不能如此比较</span></span><br><span class="line">System.out.println(Double.isNaN(num));<span class="comment">// &lt;——— 判断是否是 NaN</span></span><br><span class="line">num = <span class="number">1.0</span> / <span class="number">0</span>;</span><br><span class="line">System.out.println(Double.isInfinite(num));<span class="comment">// &lt;——— 是否是无穷大</span></span><br></pre></td></tr></table></figure></li><li><p>由于不同处理器寄存浮点数的策略可能不同，浮点数运算的结果也可能不同</p></li></ol><h2 id="6-字符类型"><a href="#6-字符类型" class="headerlink" title="6 字符类型"></a>6 字符类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以表示单个字符。（可以存放一个数字，因为其字符是数字编号的。输出时会输出数字对应的字符。”编码的概念“）</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span>; <span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;字&#x27;</span>; <span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="number">99</span>;</span><br></pre></td></tr></table></figure><h3 id="6-1-使用细节"><a href="#6-1-使用细节" class="headerlink" title="6.1 使用细节"></a>6.1 使用细节</h3><ol><li><p>字符常量用单引号括起 <code>&#39;字&#39;</code></p></li><li><p><code>char</code> 的本质是一个整数，输出时，输出的是 unicode 码对应的字符。<a href="https://unicode-table.com/cn/">Unicode 字符百科</a> </p><p>要输出那个整数，用 <code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println((<span class="type">int</span>)c1);</span><br></pre></td></tr></table></figure></li><li><p><code>char</code> 是可以进行运算的，其相当于一个整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：(int)&#x27;a&#x27; = 97</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;<span class="comment">// 相当于 char c1 = &#x27;b&#x27;</span></span><br><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);<span class="comment">// 这个代码输出 98</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span> + <span class="number">1</span>);<span class="comment">// 这个代码输出 a1</span></span><br></pre></td></tr></table></figure></li><li><p>字符允许使用转义符（<em>见 [1.8 Java 转义字符]</em>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>转义序列 出现在引号外。所有这些转义序列会在解析代码前得到处理</strong></p><ul><li><p>以下字符串是空串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\u0022+\u0022&quot;</span>;</span><br></pre></td></tr></table></figure><p>因为 022 表示引号。该代码等同于以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>以下注释会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u000A is a newline</span></span><br></pre></td></tr></table></figure><p>因为 00A 是换行符。在解析前会得到处理。在程序看来，上述注释等于以下写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">is a newline</span><br></pre></td></tr></table></figure></li><li><p>以下注释也会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// look inside c:\users</span></span><br></pre></td></tr></table></figure><p>因为程序认为，不是一个合法的转义字符</p></li><li><p>在某些场合下这种写法似乎也能实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>\u005B\u005D a;<span class="comment">// int[] a; 一个数组</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="6-2-字符本质与编码表"><a href="#6-2-字符本质与编码表" class="headerlink" title="6.2 字符本质与编码表"></a>6.2 字符本质与编码表</h3><ul><li><p>字符类型的本质，是把字符对应的码值编程二进制，存储。显示时将二进制代码转化为码值，找到对应的字符。</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte，共有 128 个字符。</p><p>Unicode 编码表，占用 2 byte，字母汉字都占用 2 byte，这样可能浪费空间。0 - 127 的字符与 ASCII 相同，所以兼容 ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1 byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode 实现方式。</p><p>GBK 编码表，可以表示汉字，字母占用 1 byte，汉字占用 2 byte。</p><p>GB2312 编码表，可以表示汉字（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li><li><p>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。包含从 U+0000 到 U+FFFF 的经典 Unicode 代码（16位，1 个代码单元），以及 U+10000 到 U+10FFFF 的辅助字符（32位，2 个代码单元）</p></li><li><p>在 Java 中，char 类型描述的是 UTF-16 编码中的 1 个代码单元。</p><p>字符串中的一个辅助字符（如 🎶）可能占用 2 个代码单元。这个场合，使用 char 可能会导致错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🎶Melody🎶&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(<span class="number">1</span>);<span class="comment">// &lt;———— 这个场合，c 是 🎶 符号的第二个代码单元而非 &#x27;M&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>因此，一般不建议在程序中使用 char 类型</strong></p></li></ul><h2 id="7-布尔类型"><a href="#7-布尔类型" class="headerlink" title="7 布尔类型"></a>7 布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或 <code>false</code> ，没有 <code>null</code>。适用于逻辑运算，通常用于程序流程控制</p><p><code>if</code> <code>while</code> <code>do-while</code> <code>for</code></p></blockquote><p><strong>使用细节：</strong></p><ol><li><p>不可以用 0 或 非0 的整数替代 <code>false</code> 或 <code>ture</code> 。这点和 C语言 不同</p></li><li><p>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> b ? <span class="number">0</span> : <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="8-基本数据类型转换"><a href="#8-基本数据类型转换" class="headerlink" title="8 基本数据类型转换"></a>8 基本数据类型转换</h2><h3 id="8-1-自动类型转换"><a href="#8-1-自动类型转换" class="headerlink" title="8.1 自动类型转换"></a>8.1 自动类型转换</h3><blockquote><p>自动类型转换：Java 在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><p><code>char</code> &gt; <code>int</code> &gt; <code>long</code> &gt; <code>float</code> &gt; <code>double</code></p><p><code>byte</code> &gt; <code>short</code> &gt; <code>int</code> &gt; <code>long</code> &gt; <code>float</code> &gt; <code>double</code></p><p>例子：<code>int a = &#39;c&#39;</code> 或者 <code>double b = 80</code></p></blockquote><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算</li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。反之进行自动类型转换。</p></li><li><p><code>byte</code> <code>short</code> <code>char</code> 三者不会相互自动转换，但可以计算。计算时首先转化为 <code>int</code>。</p><blockquote><p><code>byte a = 1;</code></p><p><code>byte b = 1;</code></p><p><code>a + b</code> 结果是 <code>int</code> 类型</p></blockquote></li><li><p><code>boolean</code> 类型不参与自动转换</p></li><li>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</li></ol><h3 id="8-2-强制类型转换"><a href="#8-2-强制类型转换" class="headerlink" title="8.2 强制类型转换"></a>8.2 强制类型转换</h3><blockquote><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符 <code>( )</code> ，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p></blockquote><h4 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li><p>当进行数据从大到小转换时，用强制转换</p></li><li><p>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code> 提升优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">3</span> * <span class="number">2.5</span> + <span class="number">1.1</span> * <span class="number">6</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>char</code> 可以保留 <code>int</code> 的常量值，但不能保存其变量值。此时需要强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)a;</span><br></pre></td></tr></table></figure></li><li><p><code>byte</code> <code>short</code> <code>char</code> 在进行运算时，当作 <code>int</code> 处理</p></li></ol><h3 id="8-3-基本数据类型和-String-的转换"><a href="#8-3-基本数据类型和-String-的转换" class="headerlink" title="8.3 基本数据类型和 String 的转换"></a>8.3 基本数据类型和 <code>String</code> 的转换</h3><ul><li><p>基本类型转 <code>String</code>：基本数据类型加上 <code>&quot; &quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> n1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(n1 + <span class="string">&quot;&quot;</span> + n1 + <span class="string">&quot;&quot;</span> + n1 + <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用 <code>parseXX</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Interger <span class="title function_">parseInt</span><span class="params">(s)</span>;</span><br></pre></td></tr></table></figure><p>特别的，把 <code>String</code> 转换为 <code>char</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);<span class="comment">// 得到 s 字符串中的第一个字符。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li>将 <code>String</code> 转成基本数据类型时，要保证其能转换为有效数据。即不能把 <code>&quot;Hello&quot;</code> 转换成 <code>int</code></li><li>如果格式不正确，会抛出异常，程序会中止</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;Java&gt;-1 基础知识</title>
      <link href="/2023/01/21/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/01/21/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java概述"><a href="#1-Java概述" class="headerlink" title="1 Java概述"></a>1 Java概述</h1><blockquote><p>程序：一系列有序指令的集合</p></blockquote><h2 id="1-1-Java-历史"><a href="#1-1-Java-历史" class="headerlink" title="1.1 Java 历史"></a>1.1 Java 历史</h2><ul><li>目前 Java 版权属于甲骨文公司</li><li>长期支持的版本只有 Java8 与 Java11。这两个版本也是最多使用的版本</li><li>Java SE：标准版、Java EE：企业版（重要）、Java ME：小型版（少）</li></ul><h2 id="1-2-Java-重要特点"><a href="#1-2-Java-重要特点" class="headerlink" title="1.2 Java 重要特点"></a>1.2 Java 重要特点</h2><p>（1）Java 语言是面向对象的（oop）</p><blockquote><p>简单来说，面向对象是一种程序设计技术。其重点放在数据（对象）和对象的接口上。</p></blockquote><p>（2）Java 语言是健壮的</p><blockquote><p>其强类型机制、异常处理、垃圾自动收集是健壮性的保证。Java 强调早期问题检测、后期动态检测，及消除易出错的情况。其编译器能检测很多其他语言仅在运行时才会发现的问题。</p></blockquote><p>（3）Java 语言是跨平台性的：一个编译好的 .class 文件可以在多个不同系统下直接运行</p><blockquote><p>Java 中没有 “依赖具体实现” 的地方。其基本数据类型大小、有关运算的行为等都有明确说明。其绝大多数库都能很好地支持平台独立性，而不用担心操作系统。</p></blockquote><p>（4）Java 语言是解释型的：解释型语言编译后需要解释器才能运行</p><blockquote><p>相对的，编译型语言可以被直接执行。Java 解释器能在任何移植了解释器的机器上直接执行 Java 字节码。</p></blockquote><h2 id="1-3-Java-的开发工具"><a href="#1-3-Java-的开发工具" class="headerlink" title="1.3 Java 的开发工具"></a>1.3 Java 的开发工具</h2><ul><li>javac：Java 编译器。将 Java 程序编译成字节码</li><li>java：Java 解释器。执行已经转换为字节码的文件</li><li>jdb：Java 调试器。调试 Java 程序</li><li>javap：反编译。将类文件还原回方法和变量</li><li>javadoc：文档生成器。创建 HTML 文件</li></ul><h2 id="1-4-Java-运行基础"><a href="#1-4-Java-运行基础" class="headerlink" title="1.4 Java 运行基础"></a>1.4 Java 运行基础</h2><blockquote><p>JVM：Java 虚拟机</p><ul><li>JVM 是—跨平台性的基础。被包含在 JDK 中</li><li>不同平台有各自对应的不同 JVM</li><li>JVM 屏蔽了底层平台的区别。能做到 ”一次编译，到处运行”<br>JDK 全称：Java Development Kit（Java 开发工具包）</li><li>JDK = JRE + Java 的开发工具（Java，Javac，Javadoc 等等）</li><li>给开发人员使用的，包含 JRE<br>JRE：Java Runtime Enviroment（Java 运行环境）</li><li>JRE = JVM + Java SE 标准类库（Java 的核心类库）</li><li>运行一个 Java 程序的基本条件</li></ul></blockquote><h2 id="1-5-Java-执行流程分析"><a href="#1-5-Java-执行流程分析" class="headerlink" title="1.5 Java 执行流程分析"></a>1.5 Java 执行流程分析</h2><blockquote><p>.Java文件（源文件） — javac（编译）— .class文件（字节码文件） — java（运行）— 结果</p></blockquote><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac [选项] 源文件名.java//[] 中是可选项</span><br></pre></td></tr></table></figure><ul><li>通过编译器将 Java 源文件编译成 JVM 可识别的字节码文件。字节码文件是二进制格式的，其格式是统一的。在源文件目录下使用 Javac 编译工具对 Java 文件进行编译。</li><li>如果没有错误将没有提示，当前目录会对应其中每一个类生成对应名称的 <code>.class</code> 文件，即字节码文件，也是可执行的 Java 程序。</li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java [选项] 程序名 [参数列表]//[] 中是可选项</span><br></pre></td></tr></table></figure><ul><li>有了可执行的 Java 程序（字节码文件）</li><li>通过运行工具<code>Java.exe</code> 对字节码文件进行执行，本质是将 <code>.class</code> 文件装载到 JVM 运行。</li></ul><p><strong><em>注意，修改后的 .Java 源文件需要重新编译</em></strong></p><h2 id="1-6-Java-开发注意事项和细节说明"><a href="#1-6-Java-开发注意事项和细节说明" class="headerlink" title="1.6 Java 开发注意事项和细节说明"></a>1.6 Java 开发注意事项和细节说明</h2><p>(1)源文件以 <code>.java</code> 为扩展名，源文件的基本组成部分是类（class）</p><p>(2)Java 应用程序的执行入口是 <code>main()</code> 方法。其有固定的<strong>书写格式：</strong><code>public static void main(string[]args)&#123;…&#125;</code></p><p>(3)Java 语言<strong>严格区分大小写</strong></p><p>(4)Java 方法由一条条语句构成，<strong>每个语句都以 <code>;</code> 结束</strong></p><p>(5)<strong>大括号 <code>&#123;</code> <code>&#125;</code> 是成对出现的</strong>，缺一不可。习惯先写 <code>&#123;&#125;</code> 再写代码</p><p>(6)一个源文件中<strong>最多只有一个 public 类</strong>，其余类不限</p><p>(7)<strong>如果文件中包含 public 类，则文件名必须按该类命名</strong></p><p>(8)也可以把 main 方法写在非 public 类中，然后运行指定非 public 类，这样入口方法是非 public 类的主方法</p><p>(9)<strong><em>在控制台按 tab 可以实现代码补齐。按方向键 ↑ 或 ↓ 可以调用历史代码</em></strong></p><h2 id="1-7-代码规范"><a href="#1-7-代码规范" class="headerlink" title="1.7 代码规范"></a>1.7 代码规范</h2><ol><li>类、方法的注释要以 Javadoc 的方式来写</li><li>非 Javadoc 的注释，往往是给维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等</li><li>不要用 <code>a</code> <code>b</code>，这种名称命名变量，尽量写得清楚 <code>int age = 10;</code>，另外，<strong>Java 源代码使用的是 Unicode 码，因此汉语也能作为标识符</strong>。但不推荐使用汉语做标识符</li><li>使用 tab 键操作，使代码右移。使用 shift+tab 键，使代码左移</li><li>运算符两边各加入空格。注意排版规范</li><li>源文件使用 UTF-8 编码</li><li>代码行宽度不要超过 80 个字符。超过时通过换行保持简洁</li><li>代码编写<strong>次行风格</strong>及<strong>行尾风格</strong></li></ol><blockquote><p>次行风格：换行输入<code>&#123;</code> <code>&#125;</code>，使其总在行头</p><p>行尾风格：在一行的末尾输入 <code>&#123;</code>，换行输入 <code>&#125;</code></p></blockquote><ol><li>一段代码完成一个小功能，尽量不要混合。这样更加灵活</li></ol><h2 id="1-8-Java-转义字符"><a href="#1-8-Java-转义字符" class="headerlink" title="1.8 Java 转义字符"></a>1.8 Java 转义字符</h2><ol><li><code>\t</code>：一个制表位，实现对齐功能</li><li><code>\n</code>：换行符</li><li><code>\\</code>：一个 <code>\</code></li><li><code>\&quot;</code>：一个 <code>&quot;</code></li><li><code>\&#39;</code>：一个 <code>&#39;</code></li><li><code>\r</code>：一个回车（不是换行）</li><li><code>\\.</code>：一个小圆点 <code>.</code></li><li><code>\b</code>：退格键</li><li><code>\u????</code>：一个具体的 Unicode 字符。其中 ???? 是 4 位 16 进制数</li><li><code>\???</code>：一个具体的 Unicode 字符。其中 ??? 是 3 位 8 进制数</li></ol><h2 id="1-9-注释"><a href="#1-9-注释" class="headerlink" title="1.9 注释"></a>1.9 注释</h2><blockquote><p>注释：用于注解说明程序的文字。其提高了代码的可读性，是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。</p><p>被注释的文字不会被 JVM 解释执行。</p></blockquote><h3 id="注释类型"><a href="#注释类型" class="headerlink" title="注释类型"></a>注释类型</h3><ul><li><strong>单行注释：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一条单行注释</span></span><br></pre></td></tr></table></figure><p>选中文字按 <code>ctrl</code> + <code>/</code> 将选中文字变为单行注释</p><ul><li><strong>多行注释：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这</span></span><br><span class="line"><span class="comment">是一段</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>多行注释中不允许多行注释嵌套。</p><ul><li><strong>文档注释：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@auther</span> Melody</span></span><br><span class="line"><span class="comment">*<span class="doctag">@version</span> 3.2.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以下写法也同样合法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">就是说咱可以每行开头不加星号的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><blockquote><p>文档注释的注释内容可被 JDK 中的 Javadoc 工具解析，生成一套以 HTML 形式体现的说明文档。</p><p>抽取注释：<code>javadoc -d 生成目录 -author -.. 文档名.java</code></p></blockquote><p>文档注释包含 <strong>标记</strong> 和紧随其后的 <strong>自由格式文本</strong>：</p><ul><li><p><strong>标记：</strong></p><ul><li><p><code>@since 始于</code>：创建一个 <strong>始于</strong> 条目。其后文本可以是引入该特性的版本的任何描述</p></li><li><p><code>@author 作者</code>：产生一个 <strong>作者</strong> 条目。可以使用多个 <code>@author</code> 标记</p></li><li><p><code>@version 版本</code>：产生一个 <strong>版本</strong> 条目。这里的文本可以是对当前版本的任意描述</p></li><li><p><code>@link 超链接</code>：产生一个 <strong>超链接</strong>，链接到 javadoc 相关部分或外部文档</p></li><li><p><code>@see 引用</code>：在 <strong>see also</strong> 部分增加一个超链接。可以添加多个 <code>@see</code> 标记，但必须放在一起</p><p>这里的 引用 有以下选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@see</span> com.test.Example#act()</span></span><br><span class="line"><span class="comment">*<span class="doctag">@see</span> &lt;a herf=&quot;../../../../../../&quot;&gt;Melody&#x27;s Box&lt;/a&gt;</span></span><br><span class="line"><span class="comment">*<span class="doctag">@see</span> &quot;一段文本&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>只提供类、方法或变量的名字。那个场合，使用 <strong>#</strong> 来分隔类名和方法名</li><li><code>@see</code> 后有一个 <strong>&lt;</strong> 字符的场合，需要指定超链接。可以指向任何 URL</li><li><code>@see</code> 后有一个 <strong>“</strong> 字符的场合，文本会显示在 see alse 部分</li></ol></blockquote></li></ul></li><li><p><strong>自由格式文本：</strong></p></li></ul><p>​    第一句应该是一个概要性的句子。javadoc 会自动抽取这些语句生成概要页</p><p>​    自由格式文本中，可以使用 HTML 修饰符</p><h4 id="注释的插入"><a href="#注释的插入" class="headerlink" title="注释的插入"></a>注释的插入</h4><p>javadoc 工具抽取文档注释时，会从以下位置抽取：</p><ul><li><p>模块</p></li><li><p>包（包注释）</p><p><strong>要想产生包注释，必须在每个包目录中添加一个单独的文件</strong></p><p>有 2 种方法:</p><ul><li>提供一个名为 package-info.java 的文件。其中 <strong>只能</strong> 包含文档注释，以及后面的一个 package 语句。不能包含更多的代码或注释。</li><li>提供一个名为 package.html 的 HTML 文件。此时会抽取 <code>&lt;body&gt;...&lt;/body&gt;</code> 间的所有文本</li></ul></li></ul><ul><li><p>公共类和接口（类注释）</p><p>类注释必须放在 import 语句后，类定义之前</p></li><li><p>公共的和受保护的字段</p><p>只需要对公共字段（通常是静态常量）建立文档</p></li><li><p>公共的和受保护的构造器和方法</p><p>方法注释必须放在所描述的方法之前。除了通用标记外，还能使用如下标记：</p><ul><li><p><code>@param 变量描述</code>：该标记能给当前方法的 <strong>参数</strong> 部分添加一个条目。该描述可以占据多行。</p><p>一个方法的所有 <code>@param</code> 标记必须放在一起</p></li><li><p><code>@return 返回值描述</code>：该标记能给当前方法的 <strong>返回值</strong> 部分添加一个条目。该描述可以占据多行</p></li><li><p><code>@throws 异常描述</code>：该标记能给当前方法的可能抛出的 <strong>异常</strong> 添加一个条目</p></li></ul></li></ul><h2 id="1-10-JShell"><a href="#1-10-JShell" class="headerlink" title="1.10 JShell"></a>1.10 JShell</h2><blockquote><p>Java 9 中引入了一种使用 Java 的方法，即 JShell。</p><p>JShell 程序提供了一个 “读取 - 计算 - 打印循环”。键入一个 Java 表达式，JShell 会评估你的输入，打印结果，并等待下一个输入。</p><p>在命令提示符中输入 <code>jshell</code> 以启动 JShell</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Melody</span>&gt;<span class="title">jshell</span></span></span><br></pre></td></tr></table></figure><p>在 cmd 中输入 jshell 以启动 JShell</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  欢迎使用 JShell -- 版本 <span class="number">11</span>.<span class="number">0</span>.<span class="number">12</span></span><br><span class="line">|  要大致了解该版本, 请键入: /<span class="built_in">help</span> intro</span><br><span class="line"></span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure><p>JShell 会显示一个问候语，之后出现提示符</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int n1 = <span class="number">10</span>;</span><br><span class="line">n1 ==&gt; <span class="number">10</span></span><br><span class="line"></span><br><span class="line">jshell&gt; n1++;</span><br><span class="line">$<span class="number">2</span> ==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>输入一条语句，JShell 会自动打印每条输入语句的值</p><p>其中的 $2 表示该值可以用于将来的计算。上面的 n1 是自己定义的标识符</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; Math.</span><br><span class="line">E                 IEEEremainder(    PI                abs(              acos(             addExact(</span><br><span class="line">asin(             atan(             atan2(            cbrt(             ceil(             class</span><br><span class="line">copySign(         cos(              cosh(             decrementExact(   exp(              expm1(</span><br><span class="line">floor(            floorDiv(         floorMod(         fma(              getExponent(      hypot(</span><br><span class="line">incrementExact(   log(              log10(            log1p(            max(              min(</span><br><span class="line">multiplyExact(    multiplyFull(     multiplyHigh(     negateExact(      nextAfter(        nextDown(</span><br><span class="line">nextUp(           pow(              random()          rint(             round(            scalb(</span><br><span class="line">signum(           sin(              sinh(             sqrt(             subtractExact(    tan(</span><br><span class="line">tanh(             toDegrees(        toIntExact(       toRadians(        ulp(</span><br></pre></td></tr></table></figure><p>输入不完整的语句后，按 tab 键实现方法补全。上面的场合，提示了所有方法的列表</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; Math.pow(</span><br></pre></td></tr></table></figure><p>自动补全后的代码。可以手动填入剩余部分。</p><p>可以按 ↑ 键自动填充运行过的代码，以实现重复运行</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="如何快速学习技术和知识点"><a href="#如何快速学习技术和知识点" class="headerlink" title="如何快速学习技术和知识点"></a>如何快速学习技术和知识点</h3><ul><li>（一）查看需求</li></ul><blockquote><ol><li>工作需要跳槽</li><li>对方要求</li><li>技术控</li></ol></blockquote><ul><li>（二）能否使用传统技术解决</li></ul><blockquote><ol><li>能解决，但不完美</li><li>解决不了</li></ol></blockquote><ul><li><p>（三）引出学习的新技术和知识点</p></li><li><p>（四）学习新技术或知识点的基本原理和基本语法（不要考虑细节）</p></li><li><p>（五）快速入门（完成一个基本程序，crud）（能跑起来给老板看）</p></li><li><p>（六）开始研究技术的注意事项，使用细节，使用规范，如何优化（无穷无尽）</p></li></ul><h3 id="DOS（只要了解）"><a href="#DOS（只要了解）" class="headerlink" title="DOS（只要了解）"></a>DOS（只要了解）</h3><blockquote><p>DOS：Disk Operating System（磁盘操作系统）</p></blockquote><h4 id="DOS-的基本原理"><a href="#DOS-的基本原理" class="headerlink" title="DOS 的基本原理"></a>DOS 的基本原理</h4><blockquote><p>在 cmd（控制台）输入指令 — DOS系统 接受指令 — 解析指令 — 执行指令</p></blockquote><ul><li><p>相对路径和绝对路径（举例从 JDK8访问到 JDK8）</p><blockquote><p>相对路径：从当前目录开始定位，形成的路径 <code>..\jre\bin\LICENSE</code></p><p>返回上一级：<code>..\</code></p><p>绝对路径：从顶级目录开始定位，形成的路径 <code>d:\Program\JDK8\jre\bin</code></p></blockquote></li></ul><h4 id="常用的-DOS-命令"><a href="#常用的-DOS-命令" class="headerlink" title="常用的 DOS 命令"></a>常用的 DOS 命令</h4><blockquote><p>查看帮助：<code>help</code> 或 <code>help cd</code> 等</p><p>查看目录内容：<code>dir</code> 查看当前目录</p><p> 或 <code>dir d:\Program\JDK8\bin</code> 查看指定目录</p><p>切换到其他盘：<code>cd /D d:</code> 从 C盘 切换至 D盘</p><p>切换到当前盘的其他目录：<code>cd d:\Program\JDK8\jre\bin</code></p><p>返回上级目录：<code>cd ..</code></p><p>切换至根目录：<code>cd \</code></p><p>查看子集目录：<code>tree</code> 当前目录</p><p> 或 <code>tree d:/Program</code> 指定目录</p><p>清屏：<code>cls</code></p><p>退出：<code>exit</code></p><p>创建/删除目录：<code>md 目录名</code> <code>rd 目录名</code></p><p>拷贝/删除文件：<code>copy 文件名 目录</code> <code>del 文件名</code></p><p>移动文件：<code>move 文件名 目录</code></p><p>…</p><p><a href="https://baike.baidu.com/item/dos/32025">DOS（操作系统）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Alibaba</title>
      <link href="/2023/01/20/SpringCloud-Alibaba/"/>
      <url>/2023/01/20/SpringCloud-Alibaba/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SpringCloud-Alibaba"><a href="#1-SpringCloud-Alibaba" class="headerlink" title="1 SpringCloud Alibaba"></a>1 SpringCloud Alibaba</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Spring Cloud Alibaba致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必须组件，方便开发者通过SpringCloud编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托SpringCloud Alibaba，您只需要添加一些注解和少量配置，就可以将SpringCloud应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。<br><a href="https://github.com/alibaba/spring-cloud-alibaba">Spring-Cloud-Alibaba</a></p><h2 id="1-2-为什么使用"><a href="#1-2-为什么使用" class="headerlink" title="1.2 为什么使用"></a>1.2 为什么使用</h2><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/20230120235524.png" alt="停止维护"></p><ul><li>SpringCloud的几大痛点<ul><li>SpringCloud部分组件停止维护和更新，给开发带来不便</li><li>SpringCloud部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发和定制</li><li>SpringCloud配置复杂，难以上手，部分配置差别难以区别和合理应用</li></ul></li><li>SpringCloud-Alibaba的优势<ul><li>阿里使用过的组件经历了考验，性能强悍，设计合理，现在开源出来大家用</li><li>成套的产品搭配完善的可视化界面给开发运维带来极大的便利</li><li>搭建简单，学习曲线低。</li></ul></li><li>结合SpringCloud Alibaba 我们最终的技术搭配方案： <blockquote><p>SpringCloud Alibaba - Nacos：注册中心（服务发现/注册）<br>SpringCloud Alibaba - Nacos：配置中心（动态配置管理）<br>SpringCloud - Ribbon：负载均衡<br>SpringCloud - Feign：声明式HTTP客户端（调用远程服务）<br>SpringCloud Alibaba - Sentinel：服务容错（限流、降级、熔断）<br>SpringCloud - Gateway：API网关（webflux编程模式）<br>SpringCloud - Sleuth：调用链监控<br>SpringCloud Alibaba - Seata：原Fescar，即分布式事务解决方案</p></blockquote></li></ul><h2 id="1-3-版本选择"><a href="#1-3-版本选择" class="headerlink" title="1.3 版本选择"></a>1.3 版本选择</h2><p>由于SpringBoot1和SpringBoot2在Actuator模块的接口和注解有很大的变更，且spring-cloud-commons从1.x.x版本升级到2.0.0版本也有较大的变更，因此我们采取跟SpringBoot版本号一致的版本:</p><ul><li>1.5.x版本适用于SpringBoot1.5.x</li><li>2.0.x版本适用于SpringBoot2.0.x</li><li>2.1.x版本适用于SpringBoot2.1.x</li></ul>]]></content>
      
      
      <categories>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谷粒商城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式基础概念</title>
      <link href="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1 微服务"></a>1 微服务</h1><p>微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是<strong>HTTP API</strong>。这些服务围绕业务能力来构建，并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言来编写，以及不同数据存储技术，并保持最低限度的集中式管理。</p><p>简而言之就是，拒绝大型单体应用，基于业务边界进行服务微化拆分，各个服务独立部署运行。</p><h1 id="2-集群-amp-分布式-amp-节点"><a href="#2-集群-amp-分布式-amp-节点" class="headerlink" title="2 集群&amp;分布式&amp;节点"></a>2 集群&amp;分布式&amp;节点</h1><p>集群是个<strong>物理形态</strong>，分布式是个<strong>工作方式</strong>。只要是一堆机器，就可以叫集群，他们是不是一起协作着干活，这个谁也不知道。</p><p>《分布式系统原理与泛型》定义：</p><blockquote><p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”，分布式系统（distributed system）是建立在网络之上的软件系统。</p></blockquote><p><strong>分布式</strong>是指将不同的业务分布在不同的地方。<strong>集群</strong>指的是将几台服务器集中在一起，实现同一业务。</p><p>例如：京东是一个分布式系统，众多业务运行在不同的机器，所有业务构成一个大型业务集群。每一个小的业务，比如用户系统，访问压力大的时候一台服务器是不够的。我们就应该将用户系统部署到多个服务器，也就是每一个业务系统也可以做集群化。</p><blockquote><p>分布式中的每一个节点，都可以做集群。而集群不一定就是分布式的。</p></blockquote><p>节点：集群中的一个服务器</p><h1 id="3-远程调用"><a href="#3-远程调用" class="headerlink" title="3 远程调用"></a>3 远程调用</h1><p>在分布式系统中，各个服务可能处于不同主机，但是服务之间不可避免的需要相互调用，我们称为远程调用。SpringCloud中使用HTTP+JSON的方式完成远程调用<br><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8.png" alt="远程调用"></p><h1 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4 负载均衡"></a>4 负载均衡</h1><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/20230120113127.png" alt="负载均衡"><br>分布式系统中，A服务需要调用B服务，B服务在多台机器中都存在，A调用任意一个服务器都可以完成功能。</p><p>为了使每一个服务器都不要太忙或者太闲，我们可以负载均衡的调用每一个服务器，提升网站的健壮性。</p><p>常见的负载均衡算法：</p><ul><li>轮询<blockquote><p>为第一个请求选择健康池中的第一个后端服务器，然后按顺序往后依次选择，知道最后一个，然后循环</p></blockquote></li><li>最小连接<blockquote><p>优先选择连接数最少，也就是压力最小的后端服务器，在会话较长的情况下可以考虑采取这种方式</p></blockquote></li><li>散列<blockquote><p>根据请求源的ip的散列（hash）来选择要转发的服务器，这种方式可以一定程度上保证特定用户能连接上相同的服务器，如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器，可以考虑采取这种方式</p></blockquote></li></ul><h1 id="5-服务注册-发现-amp-注册中心"><a href="#5-服务注册-发现-amp-注册中心" class="headerlink" title="5 服务注册/发现&amp;注册中心"></a>5 服务注册/发现&amp;注册中心</h1><p>A服务调用B服务，A服务并不知道B服务当前在哪几台服务器有，哪些正常的，哪些服务已经下线，解决这个问题可以引入<strong>注册中心</strong>。<br><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/20230120115035.png" alt="注册中心"><br>如果某些服务下线，我们其他人可以实时的感知到其他服务的状态，从而避免调用不可用的服务。</p><h1 id="6-配置中心"><a href="#6-配置中心" class="headerlink" title="6 配置中心"></a>6 配置中心</h1><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.png" alt="配置中心"><br>每一个服务最终都有大量的配置，并且每个服务都可能部署在多台机器上。我们经常需要变更配置，我们可以让每个服务在配置中心获取自己的配置。</p><blockquote><p><code>配置中心</code>用来集中管理微服务的配置信息</p></blockquote><h1 id="7-服务熔断-amp-服务降级"><a href="#7-服务熔断-amp-服务降级" class="headerlink" title="7 服务熔断&amp;服务降级"></a>7 服务熔断&amp;服务降级</h1><p>在微服务架构中，微服务之间通过网络进行通信，存在相互依赖，当其中一个服务不可用时，有可能会造成雪崩效应。要防止这样的情况，必须要有容错机制来保护服务。<br><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94.png" alt="雪崩效应"></p><ul><li>服务熔断<blockquote><p>设置服务的超时，当被调用的服务经常失败到达某个阈值，我们可以开启断路保护机制，后来的请求不再去调用这个服务。本地直接返回默认的数据</p></blockquote></li><li>服务降级<blockquote><p>在运维期间，当系统处于高峰期，系统资源紧张，我们可以让非核心业务降级运行。<strong>降级</strong>：某些服务不处理，或者简单处理【抛异常、返回NULL、调用Mork数据、调用Fallback处理逻辑】</p></blockquote></li></ul><h1 id="8-API网关"><a href="#8-API网关" class="headerlink" title="8 API网关"></a>8 API网关</h1><p>在微服务架构中，API Gateway作为整体架构的重要组件，它抽象了微服务中都需要的公共功能，同时提供了客户端负载均衡，服务自动熔断，灰度发布，统一认证，限流流控，日志统计等丰富的功能，帮助我们解决很多API管理难题。<br><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/API%E7%BD%91%E5%85%B3.png" alt="API网关"></p>]]></content>
      
      
      <categories>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 谷粒商城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis高级</title>
      <link href="/2023/01/19/MyBatis%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/01/19/MyBatis%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MyBatis的缓存"><a href="#1-MyBatis的缓存" class="headerlink" title="1 MyBatis的缓存"></a>1 MyBatis的缓存</h1><h2 id="1-1-MyBatis的一级缓存"><a href="#1-1-MyBatis的一级缓存" class="headerlink" title="1.1 MyBatis的一级缓存"></a>1.1 MyBatis的一级缓存</h2><ul><li>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  </li><li><p>使一级缓存失效的四种情况：  </p><ol><li>不同的SqlSession对应不同的一级缓存  </li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存<h2 id="1-2-MyBatis的二级缓存"><a href="#1-2-MyBatis的二级缓存" class="headerlink" title="1.2 MyBatis的二级缓存"></a>1.2 MyBatis的二级缓存</h2></li></ol></li><li>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  </li><li><p>二级缓存开启的条件</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置</li><li>在映射文件中设置标签<cache /></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol></li><li>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效<h2 id="1-3-二级缓存的相关配置"><a href="#1-3-二级缓存的相关配置" class="headerlink" title="1.3 二级缓存的相关配置"></a>1.3 二级缓存的相关配置</h2></li><li>在mapper配置文件中添加的cache标签可以设置一些属性</li><li>eviction属性：缓存回收策略  <ul><li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  </li><li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。  </li><li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。  </li><li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li><li>默认的是 LRU</li></ul></li><li>flushInterval属性：刷新间隔，单位毫秒<ul><li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li></ul></li><li>size属性：引用数目，正整数<ul><li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li></ul></li><li>readOnly属性：只读，true/false<ul><li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  </li><li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false<h2 id="1-4-MyBatis缓存查询的顺序"><a href="#1-4-MyBatis缓存查询的顺序" class="headerlink" title="1.4 MyBatis缓存查询的顺序"></a>1.4 MyBatis缓存查询的顺序</h2></li></ul></li><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  </li><li>如果二级缓存没有命中，再查询一级缓存  </li><li>如果一级缓存也没有命中，则查询数据库  </li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存<h2 id="1-5-整合第三方缓存EHCache（了解）"><a href="#1-5-整合第三方缓存EHCache（了解）" class="headerlink" title="1.5 整合第三方缓存EHCache（了解）"></a>1.5 整合第三方缓存EHCache（了解）</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="各个jar包的功能"><a href="#各个jar包的功能" class="headerlink" title="各个jar包的功能"></a>各个jar包的功能</h3>| jar包名称 | 作用 |<br>| —- | —- |<br>| mybatis-ehcache | Mybatis和EHCache的整合包 |<br>| ehcache | EHCache核心包 |<br>| slf4j-api | SLF4J日志门面包 |<br>| logback-classic | 支持SLF4J门面接口的一个具体实现 |</li></ul><h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><ul><li>名字必须叫<code>ehcache.xml</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3></li><li>在xxxMapper.xml文件中设置二级缓存类型<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3></li><li>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件<code>logback.xml</code>，名字固定，不可改变<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3>| 属性名 | 是否必须 | 作用 |<br>| —- | —- | —- |<br>| maxElementsInMemory | 是 | 在内存中缓存的element的最大数目 |<br>| maxElementsOnDisk | 是 | 在磁盘上缓存的element的最大数目，若是0表示无穷大 |<br>| eternal | 是 | 设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断 |<br>| overflowToDisk | 是 | 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 |<br>| timeToIdleSeconds | 否 | 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大 |<br>| timeToLiveSeconds | 否 | 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 |<br>| diskSpoolBufferSizeMB | 否 | DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 |<br>| diskPersistent | 否 | 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false |<br>| diskExpiryThreadIntervalSeconds | 否 | 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作 |<br>| memoryStoreEvictionPolicy | 否 | 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出 |<h1 id="2-MyBatis的逆向工程"><a href="#2-MyBatis的逆向工程" class="headerlink" title="2 MyBatis的逆向工程"></a>2 MyBatis的逆向工程</h1></li><li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li><li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：  <ul><li>Java实体类  </li><li>Mapper接口  </li><li>Mapper映射文件<h2 id="2-1-创建逆向工程的步骤"><a href="#2-1-创建逆向工程的步骤" class="headerlink" title="2.1 创建逆向工程的步骤"></a>2.1 创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MyBatis核心依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3></li></ul></li><li>文件名必须是：<code>generatorConfig.xml</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3></li><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E6%89%A7%E8%A1%8CMBG%E6%8F%92%E4%BB%B6%E7%9A%84generate%E7%9B%AE%E6%A0%87.png" alt="执行MBG插件的generate目标"></li><li>如果出现报错：<code>Exception getting JDBC Driver</code>，可能是pom.xml中，数据库驱动配置错误<ul><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/dependency%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png" alt="dependency中的驱动"></li><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png" alt="插件中的驱动"></li><li>两者的驱动版本应该相同</li></ul></li><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E9%80%86%E5%90%91%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="逆向执行结果"><h2 id="2-2-QBC"><a href="#2-2-QBC" class="headerlink" title="2.2 QBC"></a>2.2 QBC</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3></li><li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li><li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li><li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件<br><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/example%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="example的方法"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">EmpExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line"><span class="comment">//名字为张三，且年龄大于等于20</span></span><br><span class="line">example.createCriteria().andEmpNameEqualTo(<span class="string">&quot;张三&quot;</span>).andAgeGreaterThanOrEqualTo(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//或者did不为空</span></span><br><span class="line">example.or().andDidIsNotNull();</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(example);</span><br><span class="line">emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/example%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="example测试结果"><h3 id="增改"><a href="#增改" class="headerlink" title="增改"></a>增改</h3></li><li><code>updateByPrimaryKey</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null<ul><li><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png" alt="增删改测试结果1"></li></ul></li><li><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段<ul><li><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png" alt="增删改测试结果2"><h1 id="3-分页插件"><a href="#3-分页插件" class="headerlink" title="3 分页插件"></a>3 分页插件</h1><h2 id="3-1-分页插件使用步骤"><a href="#3-1-分页插件使用步骤" class="headerlink" title="3.1 分页插件使用步骤"></a>3.1 分页插件使用步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3></li></ul></li><li>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</li><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E9%85%8D%E7%BD%AE%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6.png" alt="配置分页插件"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-分页插件的使用"><a href="#3-2-分页插件的使用" class="headerlink" title="3.2 分页插件的使用"></a>3.2 分页插件的使用</h2><h3 id="开启分页功能"><a href="#开启分页功能" class="headerlink" title="开启分页功能"></a>开启分页功能</h3></li><li>在查询功能之前使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能<ul><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E5%88%86%E9%A1%B5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="分页测试结果"></p><h3 id="分页相关数据"><a href="#分页相关数据" class="headerlink" title="分页相关数据"></a>分页相关数据</h3><h4 id="方法一：直接输出"><a href="#方法一：直接输出" class="headerlink" title="方法一：直接输出"></a>方法一：直接输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//在查询到List集合后，打印分页数据</span></span><br><span class="line">System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分页相关数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;]</span><br></pre></td></tr></table></figure><h4 id="方法二使用PageInfo"><a href="#方法二使用PageInfo" class="headerlink" title="方法二使用PageInfo"></a>方法二使用PageInfo</h4></li><li>在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据<ul><li>list：分页之后的数据  </li><li>navigatePages：导航分页的页码数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">PageInfo&lt;Emp&gt; page = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(emps,<span class="number">5</span>);</span><br><span class="line">System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分页相关数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, </span><br><span class="line">list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;], </span><br><span class="line">prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;</span><br></pre></td></tr></table></figure></li><li>其中list中的数据等同于方法一中直接输出的page数据<h4 id="常用数据："><a href="#常用数据：" class="headerlink" title="常用数据："></a>常用数据：</h4></li><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数  </li><li>size：当前页显示的真实条数  </li><li>total：总记录数  </li><li>pages：总页数  </li><li>prePage：上一页的页码  </li><li>nextPage：下一页的页码</li><li>isFirstPage/isLastPage：是否为第一页/最后一页  </li><li>hasPreviousPage/hasNextPage：是否存在上一页/下一页  </li><li>navigatePages：导航分页的页码数  </li><li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis映射与动态SQL</title>
      <link href="/2023/01/19/MyBatis%E6%98%A0%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2023/01/19/MyBatis%E6%98%A0%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="1-自定义映射resultMap"><a href="#1-自定义映射resultMap" class="headerlink" title="1 自定义映射resultMap"></a>1 自定义映射resultMap</h1><h2 id="1-1-resultMap处理字段和属性的映射关系"><a href="#1-1-resultMap处理字段和属性的映射关系" class="headerlink" title="1.1 resultMap处理字段和属性的映射关系"></a>1.1 resultMap处理字段和属性的映射关系</h2><ul><li>resultMap：设置自定义映射  <ul><li>属性：  <ul><li>id：表示自定义映射的唯一标识，不能重复<ul><li>type：查询的数据要映射的实体类的类型  </li></ul></li></ul></li><li>子标签：  <ul><li>id：设置主键的映射关系</li><li>result：设置普通字段的映射关系 <ul><li>子标签属性：  <ul><li>property：设置映射关系中实体类中的属性名  </li><li>column：设置映射关系中表中的字段名</li></ul></li></ul></li></ul></li></ul></li><li>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  </p><ol><li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select eid,emp_name empName,age,sex,email from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#核心配置文件详解">核心配置文件详解</a> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-多对一映射处理"><a href="#1-2-多对一映射处理" class="headerlink" title="1.2 多对一映射处理"></a>1.2 多对一映射处理</h2><blockquote><p>查询员工信息以及员工所对应的部门信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;  </span><br><span class="line"><span class="keyword">private</span> Integer eid;  </span><br><span class="line"><span class="keyword">private</span> String empName;  </span><br><span class="line"><span class="keyword">private</span> Integer age;  </span><br><span class="line"><span class="keyword">private</span> String sex;  </span><br><span class="line"><span class="keyword">private</span> String email;  </span><br><span class="line"><span class="keyword">private</span> Dept dept;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="级联方式处理映射关系"><a href="#级联方式处理映射关系" class="headerlink" title="级联方式处理映射关系"></a>级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3></blockquote></li></ol></li><li>association：处理多对一的映射关系</li><li>property：需要处理多对的映射关系的属性名</li><li>javaType：该属性的类型<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询员工信息"><a href="#1-查询员工信息" class="headerlink" title="1. 查询员工信息"></a>1. 查询员工信息</h4></li><li>select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</li><li>column：设置分步查询的条件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmpMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Emp <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-查询部门信息"><a href="#2-查询部门信息" class="headerlink" title="2. 查询部门信息"></a>2. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeptMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-一对多映射处理"><a href="#1-3-一对多映射处理" class="headerlink" title="1.3 一对多映射处理"></a>1.3 一对多映射处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer did;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3></li><li>collection：用来处理一对多的映射关系</li><li>ofType：表示该属性对应的集合中存储的数据的类型<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询部门信息"><a href="#1-查询部门信息" class="headerlink" title="1. 查询部门信息"></a>1. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getDeptAndEmpByStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-根据部门id查询部门中的所有员工"><a href="#2-根据部门id查询部门中的所有员工" class="headerlink" title="2. 根据部门id查询部门中的所有员工"></a>2. 根据部门id查询部门中的所有员工</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-4-延迟加载"><a href="#1-4-延迟加载" class="headerlink" title="1.4 延迟加载"></a>1.4 延迟加载</h2></li><li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：<ul><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  </li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载  </li></ul></li><li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=”lazy(延迟加载)|eager(立即加载)”<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp.getEmpName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关闭延迟加载，两条SQL语句都运行了<img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%951.png" alt="延迟加载测试1"></li><li>开启延迟加载，只运行获取emp的SQL语句<br><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%952.png" alt="延迟加载测试2"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp.getEmpName());</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">System.out.println(emp.getDept());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>开启后，需要用到查询dept的时候才会调用相应的SQL语句<img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%953.png" alt="延迟加载测试3"></li><li><p>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=”lazy(延迟加载)|eager(立即加载)”</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-动态SQL"><a href="#2-动态SQL" class="headerlink" title="2 动态SQL"></a>2 动态SQL</h1></li><li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题<h2 id="2-1-if"><a href="#2-1-if" class="headerlink" title="2.1 if"></a>2.1 if</h2></li><li>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li><li>在where后面添加一个恒成立条件<code>1=1</code><ul><li>这个恒成立条件并不会影响查询的结果</li><li>这个<code>1=1</code>可以用来拼接<code>and</code>语句，例如：当empName为null时<ul><li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时<code>where</code>会与<code>and</code>连用，SQL语句会报错</li><li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code>，此时不报错<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-where"><a href="#2-2-where" class="headerlink" title="2.2 where"></a>2.2 where</h2></li></ul></li></ul></li><li>where和if一般结合使用：<ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  </li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：where标签不能去掉条件后多余的and/or</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-trim"><a href="#2-3-trim" class="headerlink" title="2.3 trim"></a>2.3 trim</h2></li><li>trim用于去掉或添加标签中的内容  </li><li>常用属性<ul><li>prefix：在trim标签中的内容的前面添加某些内容  </li><li>suffix：在trim标签中的内容的后面添加某些内容 </li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容  </li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ul></li><li>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125; or</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpByCondition</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">List&lt;Emp&gt; emps= mapper.getEmpByCondition(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/trim%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="trim测试结果"><h2 id="2-4-choose、when、otherwise"><a href="#2-4-choose、when、otherwise" class="headerlink" title="2.4 choose、when、otherwise"></a>2.4 choose、when、otherwise</h2></li><li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code></li><li>when至少要有一个，otherwise至多只有一个<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">did = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpByChoose</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.getEmpByChoose(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="literal">null</span>));</span><br><span class="line">System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/choose%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="choose测试结果"></li><li>相当于<code>if a else if b else if c else d</code>，只会执行其中一个<h2 id="2-5-foreach"><a href="#2-5-foreach" class="headerlink" title="2.5 foreach"></a>2.5 foreach</h2></li><li>属性：  <ul><li>collection：设置要循环的数组或集合  </li><li>item：表示集合或数组中的每一个数据  </li><li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li><li>open：设置foreach标签中的内容的开始符  </li><li>close：设置foreach标签中的内容的结束符</li></ul></li><li><p>批量删除</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where eid in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMoreByArray</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMoreByArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png" alt="foreach测试结果1"></p></li><li><p>批量添加</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMoreByList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;c&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertMoreByList(emps);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png" alt="foreach测试结果2"></p><h2 id="2-6-SQL片段"><a href="#2-6-SQL片段" class="headerlink" title="2.6 SQL片段"></a>2.6 SQL片段</h2></li><li>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li><li>声明sql片段：<code>&lt;sql&gt;</code>标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>引用sql片段：<code>&lt;include&gt;</code>标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis增删改查</title>
      <link href="/2023/01/19/MyBatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
      <url>/2023/01/19/MyBatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MyBatis的增删改查"><a href="#1-MyBatis的增删改查" class="headerlink" title="1 MyBatis的增删改查"></a>1 MyBatis的增删改查</h1><ol><li>添加 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">       delete from t_user where id = 6</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>修改 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">       update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询一个实体类对象 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--User getUserById();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where id = 2  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询集合 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>注意：</p><ol><li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  <ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况  </li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况  </li></ul></li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值<h1 id="2-MyBatis获取参数值的两种方式（重点）"><a href="#2-MyBatis获取参数值的两种方式（重点）" class="headerlink" title="2 MyBatis获取参数值的两种方式（重点）"></a>2 MyBatis获取参数值的两种方式（重点）</h1></li></ol></li><li>MyBatis获取参数值的两种方式：${}和#{}  </li><li>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </li><li>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号<h2 id="2-1-单个字面量类型的参数"><a href="#2-1-单个字面量类型的参数" class="headerlink" title="2.1 单个字面量类型的参数"></a>2.1 单个字面量类型的参数</h2></li><li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-多个字面量类型的参数"><a href="#2-2-多个字面量类型的参数" class="headerlink" title="2.2 多个字面量类型的参数"></a>2.2 多个字面量类型的参数</h2></li><li><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p><ol><li>以arg0,arg1…为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</li><li>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-map集合类型的参数"><a href="#2-3-map集合类型的参数" class="headerlink" title="2.3 map集合类型的参数"></a>2.3 map集合类型的参数</h2></li><li>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;usermane&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLoginByMap(map);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-实体类类型的参数"><a href="#2-4-实体类类型的参数" class="headerlink" title="2.4 实体类类型的参数"></a>2.4 实体类类型的参数</h2></li><li>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">12</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-使用-Param标识参数"><a href="#2-5-使用-Param标识参数" class="headerlink" title="2.5 使用@Param标识参数"></a>2.5 使用@Param标识参数</h2></li><li><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 </p><ol><li>以@Param注解的value属性值为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByParam</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">mapper.CheckLoginByParam(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h2></li><li><p>建议分成两种情况进行处理</p><ol><li>实体类类型的参数</li><li>使用@Param标识参数<h1 id="3-MyBatis的各种查询功能"><a href="#3-MyBatis的各种查询功能" class="headerlink" title="3 MyBatis的各种查询功能"></a>3 MyBatis的各种查询功能</h1></li></ol></li></ul><ol><li>如果查询出的数据只有一条，可以通过<ol><li>实体类对象接收</li><li>List集合接收</li><li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li></ol></li><li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过<ol><li>实体类类型的LIst集合接收</li><li>Map类型的LIst集合接收</li><li>在mapper接口的方法上添加@MapKey注解<h2 id="3-1-查询一个实体类对象"><a href="#3-1-查询一个实体类对象" class="headerlink" title="3.1 查询一个实体类对象"></a>3.1 查询一个实体类对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-查询一个List集合"><a href="#3-2-查询一个List集合" class="headerlink" title="3.2 查询一个List集合"></a>3.2 查询一个List集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-查询单个数据"><a href="#3-3-查询单个数据" class="headerlink" title="3.3 查询单个数据"></a>3.3 查询单个数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询用户的总记录数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 在MyBatis中，对于Java中常用的类型都设置了类型别名  </span></span><br><span class="line"><span class="comment"> * 例如：java.lang.Integer--&gt;int|integer  </span></span><br><span class="line"><span class="comment"> * 例如：int--&gt;_int|_integer  </span></span><br><span class="line"><span class="comment"> * 例如：Map--&gt;map,List--&gt;list  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-查询一条数据为map集合"><a href="#3-4-查询一条数据为map集合" class="headerlink" title="3.4 查询一条数据为map集合"></a>3.4 查询一条数据为map集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getUserToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-查询多条数据为map集合"><a href="#3-5-查询多条数据为map集合" class="headerlink" title="3.5 查询多条数据为map集合"></a>3.5 查询多条数据为map集合</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-特殊SQL的执行"><a href="#4-特殊SQL的执行" class="headerlink" title="4 特殊SQL的执行"></a>4 特殊SQL的执行</h1><h2 id="4-1-模糊查询"><a href="#4-1-模糊查询" class="headerlink" title="4.1 模糊查询"></a>4.1 模糊查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名进行模糊查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByLike</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  </span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><ul><li>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用的<h2 id="4-2-批量删除"><a href="#4-2-批量删除" class="headerlink" title="4.2 批量删除"></a>4.2 批量删除</h2></li><li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id批量删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMore</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMore(<span class="string">&quot;1,2,3,8&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-动态设置表名"><a href="#4-3-动态设置表名" class="headerlink" title="4.3 动态设置表名"></a>4.3 动态设置表名</h2></li><li>只能使用${}，因为表名不能加单引号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定表中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableName </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByTable</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-4-添加功能获取自增的主键"><a href="#4-4-添加功能获取自增的主键" class="headerlink" title="4.4 添加功能获取自增的主键"></a>4.4 添加功能获取自增的主键</h2></li><li>使用场景<ul><li>t_clazz(clazz_id,clazz_name)  </li><li>t_student(student_id,student_name,clazz_id)  </li></ul><ol><li>添加班级信息  </li><li>获取新添加的班级的id  </li><li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li></ol></li><li>在mapper.xml中设置两个属性<ul><li>useGeneratedKeys：设置使用自增的主键  </li></ul><ul><li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--void insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;ton&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">//输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis搭建</title>
      <link href="/2023/01/19/MyBatis%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/01/19/MyBatis%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Mybatis简介"><a href="#1-Mybatis简介" class="headerlink" title="1 Mybatis简介"></a>1 Mybatis简介</h1><h2 id="1-1-MyBatis历史"><a href="#1-1-MyBatis历史" class="headerlink" title="1.1 MyBatis历史"></a>1.1 MyBatis历史</h2><ul><li>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li><li>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）<h2 id="1-2-MyBatis特性"><a href="#1-2-MyBatis特性" class="headerlink" title="1.2 MyBatis特性"></a>1.2 MyBatis特性</h2></li></ul><ol><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架<h2 id="1-3-MyBatis下载"><a href="#1-3-MyBatis下载" class="headerlink" title="1.3 MyBatis下载"></a>1.3 MyBatis下载</h2></li></ol><ul><li><a href="https://github.com/mybatis/mybatis-3">MyBatis下载地址</a></li><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/MyBatis%E4%B8%8B%E8%BD%BD.png" alt="MyBatis下载地址"><h2 id="1-4-和其它持久化层技术对比"><a href="#1-4-和其它持久化层技术对比" class="headerlink" title="1.4 和其它持久化层技术对比"></a>1.4 和其它持久化层技术对比</h2></li><li>JDBC  <ul><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  </li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见  </li><li>代码冗长，开发效率低</li></ul></li><li>Hibernate 和 JPA<ul><li>操作简便，开发效率高  </li><li>程序中的长难复杂 SQL 需要绕过框架  </li><li>内部自动生产的 SQL，不容易做特殊优化  </li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。  </li><li>反射操作太多，导致数据库性能下降</li></ul></li><li>MyBatis<ul><li>轻量级，性能出色  </li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据  </li><li>开发效率稍逊于HIbernate，但是完全能够接受<h1 id="2-搭建MyBatis"><a href="#2-搭建MyBatis" class="headerlink" title="2 搭建MyBatis"></a>2 搭建MyBatis</h1><h2 id="2-1-开发环境"><a href="#2-1-开发环境" class="headerlink" title="2.1 开发环境"></a>2.1 开发环境</h2></li></ul></li><li>IDE：idea 2019.2  </li><li>构建工具：maven 3.5.4  </li><li>MySQL版本：MySQL 5.7  </li><li>MyBatis版本：MyBatis 3.5.7<h2 id="2-2-创建maven工程"><a href="#2-2-创建maven工程" class="headerlink" title="2.2 创建maven工程"></a>2.2 创建maven工程</h2></li><li>打包方式：jar</li><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-创建MyBatis的核心配置文件"><a href="#2-3-创建MyBatis的核心配置文件" class="headerlink" title="2.3 创建MyBatis的核心配置文件"></a>2.3 创建MyBatis的核心配置文件</h2><blockquote><p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<br>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息<br>核心配置文件存放的位置是src/main/resources目录下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的环境--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="2-4-创建mapper接口"><a href="#2-4-创建mapper接口" class="headerlink" title="2.4 创建mapper接口"></a>2.4 创建mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 添加用户信息  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-5-创建MyBatis的映射文件"><a href="#2-5-创建MyBatis的映射文件" class="headerlink" title="2.5 创建MyBatis的映射文件"></a>2.5 创建MyBatis的映射文件</h2><ul><li>相关概念：ORM（Object Relationship Mapping）对象关系映射。  <ul><li>对象：Java的实体类对象  </li><li>关系：关系型数据库  </li><li>映射：二者之间的对应关系</li></ul></li></ul></blockquote><div class="table-container"><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段/列</td></tr><tr><td>对象</td><td>记录/行</td></tr></tbody></table></div><ul><li>映射文件的命名规则<ul><li>表所对应的实体类的类名+Mapper.xml</li><li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li><li>因此一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是src/main/resources/mappers目录下</li></ul></li><li>MyBatis中可以面向接口操作数据，要保证两个一致<ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span>  </span><br><span class="line">insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)  </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-6-通过junit测试功能"><a href="#2-6-通过junit测试功能" class="headerlink" title="2.6 通过junit测试功能"></a>2.6 通过junit测试功能</h2></li></ul></li><li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li><li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li><li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line">        <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line">    <span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交<h2 id="2-7-加入log4j日志功能"><a href="#2-7-加入log4j日志功能" class="headerlink" title="2.7 加入log4j日志功能"></a>2.7 加入log4j日志功能</h2></li></ul><ol><li>加入依赖 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>加入log4j的配置文件<ul><li>log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下</li><li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-核心配置文件详解"><a href="#3-核心配置文件详解" class="headerlink" title="3 核心配置文件详解"></a>3 核心配置文件详解</h1><blockquote><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：<br>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">    default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">2. mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ol><ul><li><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/mapper%E6%8E%A5%E5%8F%A3%E5%92%8Cmapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8C%85%E4%B8%8B.png" alt="mapper接口和mapper映射文件在同一包下"><h1 id="4-默认的类型别名"><a href="#4-默认的类型别名" class="headerlink" title="4 默认的类型别名"></a>4 默认的类型别名</h1><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D1.png" alt=""></li></ul><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D2.png" alt="默认的类型别名"></p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown使用示例</title>
      <link href="/2023/01/14/markdown%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2023/01/14/markdown%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Markdown"><a href="#一、Markdown" class="headerlink" title="一、Markdown"></a>一、Markdown</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src='https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_logo.png' width='120px' style='float:left'></p><p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>当前许多网站都广泛使用 <code>Markdown</code> 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等</p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>推荐使用<code>Typora</code>，官网：<a href="https://typora.io/">https://typora.io/</a></p><h2 id="二、徽章"><a href="#二、徽章" class="headerlink" title="二、徽章"></a>二、徽章</h2><h4 id="什么是徽章"><a href="#什么是徽章" class="headerlink" title="什么是徽章"></a>什么是徽章</h4><p>徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。</p><p>常见于<code>github</code>项目主页，但其不仅出现于 <code>github</code> 项目主页，凡是能够表现图片的地方都可以出现徽章。</p><h4 id="徽章的使用"><a href="#徽章的使用" class="headerlink" title="徽章的使用"></a>徽章的使用</h4><ul><li>在<code>markdown</code>中使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式: [![图片文字说明](图片源地址)](超链接地址)  即超链接内部嵌套图片</span><br><span class="line">语法：</span><br><span class="line">[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/xugaoyi"><img src="https://img.shields.io/badge/github-xugaoyi-brightgreen.svg" alt="github"></a></p><p>徽章生成网站：<a href="https://shields.io/">https://shields.io/</a></p><p>本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 <a href="https://segmentfault.com/a/1190000019552597"> 戳我 </a> 访问。</p><h2 id="三、设置目录"><a href="#三、设置目录" class="headerlink" title="三、设置目录"></a>三、设置目录</h2><p>设置之后会根据分级标题来自动生成目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">[TOC]</span><br></pre></td></tr></table></figure><blockquote><p>注：github暂未支持。</p></blockquote><p>[TOC]</p><p>在github生成TOC的方法：<a href="https://github.com/ekalinin/github-markdown-toc">https://github.com/ekalinin/github-markdown-toc</a></p><p>windows系统需要基于golang实现的工具：<a href="https://github.com/ekalinin/github-markdown-toc.go">https://github.com/ekalinin/github-markdown-toc.go</a></p><blockquote><p>如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。</p><p>如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）</p><p>下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。</p><p>使用方法：</p><ol><li>首先将.md文档复制到gh-md-toc.exe的根目录下</li><li>在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录</li><li>把生成的目录复制到.md文件即可。</li></ol></blockquote><p><strong>这是gh-md-toc生成的目录：</strong></p><ul><li><a href="#%E4%B8%80markdown">一、Markdown</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%BA%94%E7%94%A8">应用</a></li><li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li></ul></li><li><a href="#%E4%BA%8C%E5%BE%BD%E7%AB%A0">二、徽章</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%BD%E7%AB%A0">什么是徽章</a></li><li><a href="#%E5%BE%BD%E7%AB%A0%E7%9A%84%E4%BD%BF%E7%94%A8">徽章的使用</a></li></ul></li><li><a href="#%E4%B8%89%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95">三、设置目录</a></li><li><a href="#%E5%9B%9B%E6%A0%87%E9%A2%98">四、标题</a><ul><li><a href="#%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98">一级标题</a></li></ul></li><li><a href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">二级标题</a><ul><li><a href="#%E4%B8%89%E7%BA%A7%E6%A0%87%E9%A2%98">三级标题</a><ul><li><a href="#%E5%9B%9B%E7%BA%A7%E6%A0%87%E9%A2%98">四级标题</a><ul><li><a href="#%E4%BA%94%E7%BA%A7%E6%A0%87%E9%A2%98">五级标题</a><ul><li><a href="#%E5%85%AD%E7%BA%A7%E6%A0%87%E9%A2%98">六级标题</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#%E4%BA%94%E6%96%87%E6%9C%AC">五、文本</a><ul><li><a href="#%E6%AE%B5%E8%90%BD">段落</a></li><li><a href="#%E5%AD%97%E4%BD%93">字体</a></li><li><a href="#%E5%88%A0%E9%99%A4%E7%BA%BF">删除线</a></li><li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li><li><a href="#%E6%96%87%E5%AD%97%E9%AB%98%E4%BA%AE">文字高亮</a></li><li><a href="#%E5%88%86%E9%9A%94%E7%BA%BF">分隔线</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li></ul></li><li><a href="#%E5%85%AD%E5%88%97%E8%A1%A8">六、列表</a><ul><li><a href="#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">无序列表</a></li><li><a href="#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">有序列表</a></li><li><a href="#%E6%8A%98%E5%8F%A0%E5%88%97%E8%A1%A8">折叠列表</a></li><li><a href="#%E5%B8%A6%E5%A4%8D%E9%80%89%E6%A1%86%E5%88%97%E8%A1%A8">带复选框列表</a></li><li><a href="#%E5%88%97%E8%A1%A8%E5%B5%8C%E5%A5%97">列表嵌套</a></li></ul></li><li><a href="#%E4%B8%83%E5%8C%BA%E5%9D%97%E5%BC%95%E7%94%A8">七、区块引用</a><ul><li><a href="#%E5%8C%BA%E5%9D%97%E5%B5%8C%E5%A5%97">区块嵌套</a></li><li><a href="#%E5%8C%BA%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8">区块中使用列表</a></li><li><a href="#%E5%88%97%E8%A1%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9D%97">列表中使用区块</a></li></ul></li><li><a href="#%E5%85%AB%E4%BB%A3%E7%A0%81">八、代码</a><ul><li><a href="#%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97">代码区块</a></li></ul></li><li><a href="#%E4%B9%9D%E9%93%BE%E6%8E%A5">九、链接</a><ul><li><a href="#%E5%8F%98%E9%87%8F%E9%93%BE%E6%8E%A5">变量链接</a></li><li><a href="#github%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5">Github中使用内部链接</a></li><li><a href="#%E9%94%9A%E7%82%B9%E9%93%BE%E6%8E%A5">锚点链接</a></li></ul></li><li><a href="#%E5%8D%81%E5%9B%BE%E7%89%87">十、图片</a><ul><li><a href="#%E5%9B%BE%E7%89%87%E5%AE%BD%E9%AB%98">图片宽高</a></li><li><a href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8Agithub%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87">相对路径以及Github中使用图片</a></li></ul></li><li><a href="#%E5%8D%81%E4%B8%80%E8%A1%A8%E6%A0%BC">十一、表格</a></li><li><a href="#%E5%8D%81%E4%BA%8Cemoji%E8%A1%A8%E6%83%85%E5%8C%85">十二、Emoji表情包</a></li><li><a href="#%E5%8D%81%E4%B8%89%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7">十三、其他技巧</a><ul><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84-html-%E5%85%83%E7%B4%A0">支持的 HTML 元素</a></li><li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li><li><a href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">数学公式</a></li><li><a href="#%E5%9B%BE%E8%A1%A8">图表</a></li><li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></li><li><a href="#%E6%97%B6%E5%BA%8F%E5%9B%BE">时序图</a></li><li><a href="#%E7%94%98%E7%89%B9%E5%9B%BE">甘特图</a></li></ul></li></ul><h2 id="四、标题"><a href="#四、标题" class="headerlink" title="四、标题"></a>四、标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="五、文本"><a href="#五、文本" class="headerlink" title="五、文本"></a>五、文本</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>Markdown 段落没有特殊的格式，直接编写文字，<strong>需要段落缩进时使用2个Tab</strong></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">*斜体文本* </span><br><span class="line">或 _斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">或  __粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">或 ___粗斜体文本___</span><br></pre></td></tr></table></figure><p><em>斜体文本</em></p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><strong>粗体文本</strong></p><p><strong><em>粗斜体文本</em></strong></p><p><strong><em>粗斜体文本</em></strong></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure><p><del>BAIDU.COM</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <code>&lt;u&gt;&lt;/u&gt;</code> 标签来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&lt;u&gt;带下划线的文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注：github暂未支持。</p></blockquote><p><u>带下划线的文本</u></p><h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><p>文字高亮功能能使行内部分文字高亮，使用一对反引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">`html` `css` `javascript` </span><br></pre></td></tr></table></figure><p><code>html</code> <code>css</code> <code>javascript</code> </p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><hr><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">[^变量]</span><br><span class="line">在文档结尾或其他位置給变量赋值：</span><br><span class="line">[^变量]: 注明框内显示的内容</span><br><span class="line"></span><br><span class="line">鼠标移到这里&gt; [^哈喽]</span><br><span class="line">[^哈喽]: 注明框内显示的内容</span><br></pre></td></tr></table></figure><blockquote><p>注：github暂未支持。</p></blockquote><p>鼠标移到这里&gt; <sup><a href="#fn_哈喽" id="reffn_哈喽">哈喽</a></sup></p><blockquote id="fn_哈喽"><sup>哈喽</sup>. 注明框内显示的内容<a href="#reffn_哈喽" title="Jump back to footnote [哈喽] in the text."> &#8617;</a></blockquote><h2 id="六、列表"><a href="#六、列表" class="headerlink" title="六、列表"></a>六、列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用星号(<strong>*</strong>)、加号(<strong>+</strong>)或是减号(<strong>-</strong>)作为列表标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字并加上 <strong>.</strong> 号来表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li></ol><h3 id="折叠列表"><a href="#折叠列表" class="headerlink" title="折叠列表"></a>折叠列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;点我打开关闭折叠&lt;/summary&gt;</span><br><span class="line"> 折叠内容</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">     &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">     &lt;li&gt;3&lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：\<details\> 标签内写markdown代码无效，可写html代码，如ul&gt;li、table等</p></blockquote><details><summary>点我打开关闭折叠</summary> 折叠内容 <ul>     <li>1</li>     <li>2</li>     <li>3</li> </ul></details><details><summary>包含table的折叠</summary>    <table>        <thead>            <tr>                <th align="center">分类</th>                <th align="center">例词</th>            </tr>        </thead>        <tbody>            <tr>                <td align="center">人称代词-主格</td>                <td align="center">I我，you你，he他，she她，they他们， we我们</td>            </tr>            <tr>                <td align="center">人称代词-宾格</td>                <td align="center">me我， you你， him他， her她， them他们， us我们</td>            </tr>            <tr>                <td align="center">物主代词</td>                <td align="center">my我的， his他的， your你的（your你们的）， their他们的， hers她的</td>            </tr>            <tr>                <td align="center">指示代词</td>                <td align="center">this这， that那， these这些， those 那些</td>            </tr>            <tr>                <td align="center">反身代词</td>                <td align="center">myself我自己， himself他自己， themselves他们自己， yourself你(们)自己，herself她自己</td>            </tr>            <tr>                <td align="center">疑问代词</td>                <td align="center">who谁， what什么， which哪个</td>            </tr>            <tr>                <td align="center">不定代词</td>                <td align="center">some一些， many许多， both两个、两个都， any许多</td>            </tr>            <tr>                <td align="center">关系代词</td>                <td align="center">which……的物， who……的人， that……的人或物， who谁， that引导定语从句</td>            </tr>            <tr>                <td align="center">相互代词</td>                <td align="center">each other 互相， one another互相</td>            </tr>            <tr>                <td align="center">连接代词</td>                <td align="center">who,whom,whose,what,which,whatever,whichever,whoever,whomever</td>            </tr>            <tr>                <td align="center">替代词</td>                <td align="center">one（单数），ones（复数）</td>            </tr>        </tbody>    </table></details><h3 id="带复选框列表"><a href="#带复选框列表" class="headerlink" title="带复选框列表"></a>带复选框列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">* [x] 第一项</span><br><span class="line">* [ ] 第二项</span><br><span class="line">* [ ] 第三项</span><br></pre></td></tr></table></figure><ul><li><p>[ ] 第一项</p></li><li><p>[ ] 第二项</p></li><li><p>[x] 第三项</p></li></ul><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br></pre></td></tr></table></figure><ol><li>第一项<ul><li>嵌套1</li><li>嵌套2</li></ul></li><li>第二项<pre><code>- 嵌套1   - 嵌套2</code></pre></li></ol><h2 id="七、区块引用"><a href="#七、区块引用" class="headerlink" title="七、区块引用"></a>七、区块引用</h2><p>区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&gt; 区块引用</span><br></pre></td></tr></table></figure><blockquote><p>区块引用</p><p>回车键自动延伸区块</p></blockquote><h4 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&gt; 第一层</span><br><span class="line">&gt; &gt; 第二层</span><br><span class="line">&gt; &gt; &gt; 第三层</span><br></pre></td></tr></table></figure><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p></blockquote></blockquote></blockquote><h4 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; * 111</span><br><span class="line">&gt; * 222</span><br></pre></td></tr></table></figure><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项<ul><li>111</li><li>222</li></ul></li></ol></blockquote><h4 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">* 第一项</span><br><span class="line">    &gt; 区块</span><br><span class="line">* 第二项</span><br></pre></td></tr></table></figure><ul><li><p>第一项</p><blockquote><p>区块</p><p>区块</p></blockquote></li><li><p>第二项</p></li></ul><h2 id="八、代码"><a href="#八、代码" class="headerlink" title="八、代码"></a>八、代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（<strong>`</strong>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">`function()` 函数</span><br></pre></td></tr></table></figure><p><code>function()</code>函数</p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p><p>本代码区块为说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">​```javascript</span><br><span class="line">function test() &#123;</span><br><span class="line">alert(&#x27;test&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、链接"><a href="#九、链接" class="headerlink" title="九、链接"></a>九、链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">[链接名称](链接地址,可选的alt)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">[百度](http://www.baidu.com,&#x27;百度&#x27;)</span><br></pre></td></tr></table></figure><p><a href="http://www.baidu.com,&#39;百度&#39;">百度</a></p><p>直接显示链接地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&lt;http://www.baidu.com&gt;</span><br></pre></td></tr></table></figure><p><a href="http://www.baidu.com">http://www.baidu.com</a></p><h3 id="变量链接"><a href="#变量链接" class="headerlink" title="变量链接"></a>变量链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">链接可以用变量来代替，文档末尾或其他位置附带变量地址：</span><br><span class="line">这个链接用 1 作为网址变量 [Google][1]</span><br><span class="line">这个链接用 baidu 作为网址变量 [Baidu][baidu]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: http://www.google.com/</span><br><span class="line">  [baidu]: http://www.baidu.com/</span><br></pre></td></tr></table></figure><p><a href="http://www.google.com">Google</a></p><p><a href="http://www.baidu.com/">Baidu</a></p><h3 id="Github中使用内部链接"><a href="#Github中使用内部链接" class="headerlink" title="Github中使用内部链接"></a>Github中使用内部链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">可使用相对路径（前提是有该路径下的文件）</span><br><span class="line">[test](test.md)</span><br></pre></td></tr></table></figure><p><a href="./test/test.md">test</a></p><h3 id="锚点链接"><a href="#锚点链接" class="headerlink" title="锚点链接"></a>锚点链接</h3><p>本文件中每一个标题都是一个锚点，和HTML的锚点（<code>#</code>）类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">[Markdown](#Markdown)</span><br></pre></td></tr></table></figure><blockquote><p>注： github对含有标点符号的标题进行锚点时会忽略掉标点符号，<br>本页中，如果这样写则无法跳转：[链接](#九、链接)<br>正确写法：[链接](#九链接)</p></blockquote><p><a href="#一Markdown">Markdown</a></p><p><a href="#九链接">链接</a>     </p><p><a href="#流程图">流程图</a></p><h2 id="十、图片"><a href="#十、图片" class="headerlink" title="十、图片"></a>十、图片</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">![alt替代文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt替代文本](图片地址 &quot;title标题&quot;)</span><br></pre></td></tr></table></figure><ul><li><p>开头一个感叹号 !</p></li><li><p>接着一个方括号，里面放上图片的替代文字</p></li><li><p>接着一个普通括号，里面放上图片的地址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">![logo](https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_logo.png &quot;logo&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_logo.png" alt="logo" title="logo"></p><p>当然，你也可以像链接那样对图片地址使用变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里链接用 img 作为图片地址变量 </span><br><span class="line">然后在文档的结尾或其他位置给变量赋值（图片地址）</span><br><span class="line">语法：</span><br><span class="line">![RUNOOB][img]</span><br><span class="line">[img]: https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_logo.png</span><br></pre></td></tr></table></figure><p> <img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_logo.png" alt="RUNOOB"></p><h3 id="图片宽高"><a href="#图片宽高" class="headerlink" title="图片宽高"></a>图片宽高</h3><p>如下想设置图片宽高，可以使用 <img> 标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">&lt;img src=&quot;https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_logo.png&quot; width=&quot;50px&quot; height=&quot;30px&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_logo.png" width="50px" height="30px"></p><h3 id="相对路径以及Github中使用图片"><a href="#相对路径以及Github中使用图片" class="headerlink" title="相对路径以及Github中使用图片"></a>相对路径以及Github中使用图片</h3><p>不管是在本地还是在github同一个仓库中，如果图片存在，可以使用<strong>相对路径</strong>。github上如果引用其他github仓库中的图片则要注意地址格式，即：<code>仓库地址/raw/分支名/图片路径</code></p><p>相对路径图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">![头像图片](https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_test.jpg)</span><br></pre></td></tr></table></figure><p><img src="https://moruo-img.oss-cn-shenzhen.aliyuncs.com/img/Markdown/markdown_test.jpg" alt="头像图片"></p><p>其他仓库的图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">![其他仓库的图片](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png" alt="其他仓库的图片"></p><h2 id="十一、表格"><a href="#十一、表格" class="headerlink" title="十一、表格"></a>十一、表格</h2><p>制作表格使用 (<strong>|</strong>) 来分隔不同的单元格，使用( <strong>-</strong>) 来分隔表头和其他行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">表头</th><th style="text-align:center">表头</th></tr></thead><tbody><tr><td style="text-align:center">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:center">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table></div><p><strong>对齐方式</strong></p><ul><li><strong>-:</strong> 设置内容和标题栏居右对齐  </li><li><strong>:-</strong> 设置内容和标题栏居左对齐</li><li><strong>:-:</strong> 设置内容和标题栏居中对齐</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table></div><h2 id="十二、Emoji表情包"><a href="#十二、Emoji表情包" class="headerlink" title="十二、Emoji表情包"></a>十二、Emoji表情包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：  Emoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示</span><br><span class="line">如：</span><br><span class="line">:smirk:</span><br></pre></td></tr></table></figure><p>:kiss:<br>:smile_cat::see_no_evil::horse:<br>:smirk::blush::smiley::smile: :sunny:</p><p>更多表情名称请查看：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">表情包清单</a></p><h2 id="十三、其他技巧"><a href="#十三、其他技巧" class="headerlink" title="十三、其他技巧"></a>十三、其他技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><p>不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</span><br></pre></td></tr></table></figure><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><p><b>使用b标签的加粗字体</b></p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">**未转义星号显示加粗** </span><br><span class="line">\*\* 转义显示星号 \*\*</span><br></pre></td></tr></table></figure><p><strong>未转义星号显示加粗</strong><br>** 转义显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><hr><p><em>\</em>* <strong>以下部分在Github暂未支持</strong> ***</p><hr><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} & \mathbf{j} & \mathbf{k} \\\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0 \\\end{vmatrix}</script><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">​```chart</span><br><span class="line">,Budget,Income,Expenses,Debt</span><br><span class="line">June,5000,8000,4000,6000</span><br><span class="line">July,3000,1000,4000,3000</span><br><span class="line">Aug,5000,7000,6000,3000</span><br><span class="line">Sep,7000,2000,3000,1000</span><br><span class="line">Oct,6000,5000,4000,2000</span><br><span class="line">Nov,4000,3000,5000,</span><br><span class="line"></span><br><span class="line">type: pie</span><br><span class="line">title: Monthly Revenue</span><br><span class="line">x.title: Amount</span><br><span class="line">y.title: Month</span><br><span class="line">y.suffix: $</span><br><span class="line">​```</span><br><span class="line">​```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: 是否已收到消息？</span><br><span class="line">B--&gt;&gt;A: 已收到消息</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><blockquote><p>注：在Typora中未支持</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">,Budget,Income,Expenses,Debt</span><br><span class="line">June,5000,8000,4000,6000</span><br><span class="line">July,3000,1000,4000,3000</span><br><span class="line">Aug,5000,7000,6000,3000</span><br><span class="line">Sep,7000,2000,3000,1000</span><br><span class="line">Oct,6000,5000,4000,2000</span><br><span class="line">Nov,4000,3000,5000,</span><br><span class="line"></span><br><span class="line">type: pie</span><br><span class="line">title: Monthly Revenue</span><br><span class="line">x.title: Amount</span><br><span class="line">y.title: Month</span><br><span class="line">y.suffix: $</span><br></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">​```mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[模块A] --&gt;|A1| B(模块B)</span><br><span class="line">B --&gt; C&#123;判断条件C&#125;</span><br><span class="line">C --&gt;|条件C1| D[模块D]</span><br><span class="line">C --&gt;|条件C2| E[模块E]</span><br><span class="line">C --&gt;|条件C3| F[模块F]</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><p>流程图相关文章：<a href="https://www.jianshu.com/p/b421cc723da5">https://www.jianshu.com/p/b421cc723da5</a></p><p><a href="http://www.imooc.com/article/292708">http://www.imooc.com/article/292708</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[模块A] --&gt;|A1| B(模块B)</span><br><span class="line">B --&gt; C&#123;判断条件C&#125;</span><br><span class="line">C --&gt;|条件C1| D[模块D]</span><br><span class="line">C --&gt;|条件C2| E[模块E]</span><br><span class="line">C --&gt;|条件C3| F[模块F]</span><br></pre></td></tr></table></figure><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">​```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: 是否已收到消息？</span><br><span class="line">B--&gt;&gt;A: 已收到消息</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: 是否已收到消息？</span><br><span class="line">B--&gt;&gt;A: 已收到消息</span><br></pre></td></tr></table></figure><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">​```mermaid</span><br><span class="line">gantt</span><br><span class="line">title 甘特图</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">section 项目A</span><br><span class="line">任务1           :a1, 2018-06-06, 30d</span><br><span class="line">任务2     :after a1  , 20d</span><br><span class="line">section 项目B</span><br><span class="line">任务3      :2018-06-12  , 12d</span><br><span class="line">任务4      : 24d</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">title 甘特图</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">section 项目A</span><br><span class="line">任务1           :a1, 2018-06-06, 30d</span><br><span class="line">任务2     :after a1  , 20d</span><br><span class="line">section 项目B</span><br><span class="line">任务3      :2018-06-12  , 12d</span><br><span class="line">任务4      : 24d</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                                 <a href="#一Markdown">回到顶部</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
